ğŸ§¨ B. 250 Thousand Tons of TNT â€” Notes
link: https://codeforces.com/problemset/problem/1899/B
ğŸ§© Problem Understanding

Youâ€™re given:

An array a[1...n] (weights of boxes)

You must group them into trucks, each truck carrying exactly k boxes.

That means:

You divide the array into consecutive segments of size k.

This is only possible if n % k == 0 (so all trucks have equal boxes).

ğŸ¯ Goal

For each valid k (divisor of n):

Divide the array into chunks of size k.

Compute the sum of boxes in each chunk.

Find:

max_sum = maximum sum among chunks
min_sum = minimum sum among chunks


The difference = max_sum - min_sum

You need the maximum such difference over all possible k.

ğŸ§  Example
Example 1
n = 2
a = [1, 2]


k = 1 â†’ groups: [1], [2]

sums = [1, 2] â†’ diff = 1

k = 2 â†’ groups: [1, 2]

only one truck â†’ diff = 0

âœ… answer = max(1, 0) = 1

Example 2
n = 6
a = [10, 2, 3, 6, 1, 3]


Divisors of 6 â†’ [1, 2, 3, 6]

k	Groups (each of size k)	Group sums	max-min
1	[10][2][3][6][1][3]	10,2,3,6,1,3	9
2	[10+2][3+6][1+3]	12,9,4	8
3	[10+2+3][6+1+3]	15,10	5
6	[10+2+3+6+1+3]	25	0

âœ… answer = max(9, 8, 5, 0) = 9

âš™ï¸ Key Observations

Only check divisors of n
Because only divisors divide the array evenly into chunks.

Each group sum = sum of k consecutive elements.

Use prefix sums to compute group sums quickly:

sum(l,r)=prefix[r]âˆ’prefix[lâˆ’1]

where each group has r - l + 1 = k.

The total number of divisors â‰¤ âˆšn * 2 â€” small enough to check all.

For each k, youâ€™ll have n/k groups.

ğŸ§© Algorithm

Compute all divisors of n â†’ factors = allfactor(n)

Compute prefix sums of array a.

For each divisor k:

Initialize max_sum = -âˆ, min_sum = +âˆ

For each truck i (0 to n/k - 1):

group_sum = prefix[(i+1)k] - prefix[ik]

update max_sum, min_sum

diff = max_sum - min_sum

Update answer = max(answer, diff)

Print the final answer.

ğŸ’» Final Optimized Code
#include <bits/stdc++.h>
using namespace std;

vector<int> getDivisors(int n) {
    vector<int> res;
    for (int i = 1; i * i <= n; i++) {
        if (n % i == 0) {
            res.push_back(i);
            if (i != n / i)
                res.push_back(n / i);
        }
    }
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<long long> a(n);
        for (auto &x : a) cin >> x;

        vector<long long> prefix(n + 1, 0);
        for (int i = 0; i < n; i++) prefix[i + 1] = prefix[i] + a[i];

        vector<int> divisors = getDivisors(n);
        long long ans = 0;

        for (int k : divisors) {
            long long mx = LLONG_MIN, mn = LLONG_MAX;
            for (int i = k; i <= n; i += k) {
                long long sum = prefix[i] - prefix[i - k];
                mx = max(mx, sum);
                mn = min(mn, sum);
            }
            ans = max(ans, mx - mn);
        }

        cout << ans << "\n";
    }
}

ğŸ“ˆ Complexity Analysis
Step	Complexity
Finding divisors	O(âˆšn)
Prefix sum	O(n)
Checking all divisors	O(n / k) per divisor
Total (all divisors)	O(n * âˆšn / average divisor spacing) â†’ practically O(n log n)
Fits well in constraints (n â‰¤ 1.5Ã—10âµ total) âœ…	
ğŸ§  Key Takeaways

Always check divisors when the problem says â€œdivide into equal groupsâ€.

Prefix sums are your best friend when repeatedly calculating segment sums.

Avoid nested O(nÂ²) loops â€” think of mathematical patterns (divisors).

If array has equal elements â†’ all group sums equal â†’ answer = 0.

ğŸ Summary
Concept	Description
Problem type	Array + Math (Divisors + Prefix sum)
Key logic	Only divisors of n give valid k
Core formula	diff = max(group_sums) - min(group_sums)
Optimization	Prefix sums for O(1) segment sum
Final time complexity	O(n + âˆšn * (n/k)) â‰ˆ O(n log n)
