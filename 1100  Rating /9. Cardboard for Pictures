ğŸ–¼ï¸ E. Cardboard for Pictures â€” Final Notes
ğŸ”¹ Problem Summary
link: https://codeforces.com/problemset/problem/1850/E
You have n square paintings,
each of side s[i] cm.

Each painting is mounted on a square cardboard having a border of width w on all sides.

So cardboard side = s[i] + 2w.

ğŸ‘‰ Total cardboard area used:

Total=âˆ‘ğ‘–=1ğ‘›(ğ‘ ğ‘–+2ğ‘¤)2=ğ‘Total=i=1âˆ‘n	â€‹(si	â€‹+2w)2=c

Given all s[i] and total c, find integer w â‰¥ 1.

ğŸ”¹ Key Equation
âˆ‘ğ‘–=1ğ‘›(ğ‘ ğ‘–+2ğ‘¤)2=ğ‘i=1âˆ‘n	â€‹(si	â€‹+2w)2=c

Expand if you want intuition:

âˆ‘(ğ‘ ğ‘–2+4ğ‘ ğ‘–ğ‘¤+4ğ‘¤2)=âˆ‘ğ‘ ğ‘–2+4ğ‘¤âˆ‘ğ‘ ğ‘–+4ğ‘›ğ‘¤2âˆ‘(si2	â€‹+4si	â€‹w+4w2)=âˆ‘si2	â€‹+4wâˆ‘si	â€‹+4nw2

âœ… This grows monotonically with w, so we can use binary search.

ğŸ”¹ Observation

For small w, area is less than c.

For large w, area is more than c.
â¡ï¸ Thereâ€™s a unique w where total == c.
Hence binary search fits perfectly.

ğŸ”¹ Binary Search Steps

Range: low = 1, high = 1e9 (safe upper bound)

For each mid:

Compute total = Î£ (s[i] + 2*mid)^2

Compare with c:

If total == c â†’ found answer

If total < c â†’ need larger w

If total > c â†’ need smaller w

Print final w.

ğŸ”¹ Time Complexity

Each check = O(n)

Binary search â‰ˆ O(log(1e9)) â‰ˆ 30 steps

Total per test: O(n log W)

Works easily for n â‰¤ 2Ã—10^5.

ğŸ”¹ Careful with Data Types

(s[i] + 2w)^2 can overflow 64-bit.
âœ… Use __int128 (C++) or Python int (unlimited).

ğŸ”¹ C++ Code (clean & simple)
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    cin >> t;
    while (t--) {
        int n;
        long long c;
        cin >> n >> c;
        vector<long long> s(n);
        for (auto &x : s) cin >> x;

        long long low = 1, high = 1e9, ans = -1;
        while (low <= high) {
            long long mid = (low + high) / 2;
            __int128 total = 0;
            for (auto x : s) {
                __int128 val = x + 2 * mid;
                total += val * val;
                if (total > c) break;
            }

            if (total == c) {
                ans = mid;
                break;
            } else if (total < c) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        cout << ans << "\n";
    }
    return 0;
}

ğŸ”¹ Example Dry Run

Input:

3 50
3 2 1


Try w = 1

(3+2)2+(2+2)2+(1+2)2=25+16+9=50
âœ…
(3+2)
2
+(2+2)
2
+(1+2)
2
=25+16+9=50âœ…

â†’ Answer: w = 1

ğŸ”¹ Trick to Recognize This Pattern

Whenever you see:

â€œFind x such that sum(f(x)) = constantâ€
and f(x) increases with x

â¡ï¸ Binary search on x.

ğŸ”¹ Summary Table
Symbol	Meaning
n	number of paintings
s[i]	side of i-th painting
w	cardboard border width
c	total cardboard area
Formula	Î£ (s[i] + 2w)Â² = c
Technique	Binary Search
Data Type	use __int128 for safety
ğŸ’¥ Key Takeaway

Hidden binary search pattern:
Monotonic function + find point = constant â†’ Binary Search!
