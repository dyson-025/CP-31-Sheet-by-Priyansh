ğŸ§¾ Notes â€“ Coprime Indices Problem
 link: https://codeforces.com/problemset/problem/1742/D
ğŸ“˜ Problem Statement

You are given an array v of size n.
You need to find the maximum possible sum of indices (1-indexed) i + j such that:

gcd
(
ğ‘£
[
ğ‘–
]
,
ğ‘£
[
ğ‘—
]
)
=
1
gcd(v[i],v[j])=1

If no such pair exists, print -1.

ğŸ” Example

Input:

1
4
2 3 4 6


Output:

5


Explanation:

gcd(2, 3) = 1 â†’ i+j = 1+2 = 3

gcd(3, 4) = 1 â†’ i+j = 2+3 = 5 âœ… (maximum)

gcd(4, 6) = 2 âŒ

gcd(2, 6) = 2 âŒ
â†’ Answer = 5

ğŸš« Naive Approach (O(nÂ²))

Check all pairs (i, j):

for (int i = 0; i < n; i++) {
    for (int j = i; j < n; j++) {
        if (gcd(v[i], v[j]) == 1)
            ans = max(ans, i + j + 2); // +2 because 1-based
    }
}


â±ï¸ Time Complexity = O(nÂ²) â†’ Too slow for n = 1e5

âš¡ Optimized Approach (O(n + 1000Â²))
ğŸ§© Key Idea

The array values are bounded: 1 â‰¤ v[i] â‰¤ 1000

So there are only 1000 possible distinct values

Instead of checking all pairs of indices, we check all pairs of values (1..1000)

ğŸ’¡ Observation

If two numbers a and b are coprime (gcd(a, b) == 1),
then any occurrence of a and b in the array forms a valid pair.

So we only need:

The last index of each value (to get maximum i+j)

To loop over all (a, b) in [1..1000]

âœ… Algorithm Steps

Initialize an array last[1001] with zeros.

For each element v[i], set:

last[v[i]] = i + 1; // store last (1-based) index


Initialize ans = -1.

For each pair (a, b) in [1..1000]:

If both appear (last[a] > 0 and last[b] > 0)

And gcd(a, b) == 1

Update:

ans = max(ans, last[a] + last[b]);


Output ans.

ğŸ§® Code Implementation
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<int> v(n);
        for (int i = 0; i < n; i++) cin >> v[i];

        vector<int> last(1001, 0);
        for (int i = 0; i < n; i++)
            last[v[i]] = i + 1; // store last 1-based index

        int ans = -1;
        for (int a = 1; a <= 1000; a++) {
            for (int b = 1; b <= 1000; b++) {
                if (last[a] && last[b] && gcd(a, b) == 1) {
                    ans = max(ans, last[a] + last[b]);
                }
            }
        }

        cout << ans << "\n";
    }
}

ğŸ§  Concept Recap
Concept	Meaning
GCD	Greatest Common Divisor
Coprime	Two numbers whose gcd = 1
1-indexed	Problemâ€™s index starts from 1 (so add +1 to 0-based index)
Optimization Trick	Replace nÂ² index loop with limited (value range) loop
â±ï¸ Complexity Analysis
Step	Complexity
Build last array	O(n)
Double loop on values (1â€“1000)	O(1000Â²) = 1e6
GCD computation	O(log(max(a,b))) per pair
Total	â‰ˆ O(n + 1e6) â†’ Fast enough

âœ… Works up to n = 1e5

ğŸ Final Notes

The trick of using value frequency / last index is very useful whenever array elements are bounded by a small constant (like 1000 or 10âµ).

Commonly used in Codeforces problems like:

Coprime Indices (1742C)

Coprime Array

Beautiful Array Variants
