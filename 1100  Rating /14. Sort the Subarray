ðŸ“˜ Problem: Sort the Subarray
ðŸ§© Statement
link: https://codeforces.com/problemset/problem/1821/B
You are given two arrays:

a â†’ original array

aâ€² â†’ array obtained by sorting exactly one contiguous subarray (from l to r) of a in non-decreasing order.

Your task:
Find the indices l and r (1-based) such that sorting a[l..r] gives aâ€².

If multiple possible pairs exist:

Choose the one with maximum length.

If still multiple, any one is fine.

ðŸ“¥ Input Format
t                â†’ number of test cases
n                â†’ size of array
a1 a2 ... an     â†’ original array
aâ€²1 aâ€²2 ... aâ€²n  â†’ modified array after sorting subarray


Constraints:

1 â‰¤ t â‰¤ 10^4

2 â‰¤ n â‰¤ 2Ã—10^5

Sum of all n â‰¤ 2Ã—10^5

It is guaranteed that aâ€² can be formed by sorting one subarray of a.

ðŸ“¤ Output Format

Print l r for each test case.

ðŸ§  Intuition & Thought Process

We know:

Only one continuous subarray was sorted.

Everything outside that subarray must be unchanged.

So, differences between a and aâ€² will appear only inside that range.

ðŸ” Step 1: Find the first mismatch

Let
l = first index (from left) where a[i] != aâ€²[i]

Because before that index, everything is identical (sorting didnâ€™t affect them).

ðŸ” Step 2: Find the last mismatch

Let
r = last index (from right) where a[i] != aâ€²[i]

Because after that index, everything is identical again.

Now we have a minimal range [l, r] where sorting likely occurred.

âš™ï¸ Step 3: Expand the range

Sometimes sorting affects a slightly larger region â€”
especially when adjacent values are already sorted and equal.

So we expand the range while it still forms a non-decreasing sequence in aâ€².

while (l > 0 && aâ€²[l-1] <= aâ€²[l]) l--;
while (r + 1 < n && aâ€²[r] <= aâ€²[r+1]) r++;


This ensures we cover the longest valid subarray that keeps aâ€² sorted.

ðŸ§¾ Final Algorithm

1ï¸âƒ£ Read t.
2ï¸âƒ£ For each test case:

Read n, a[], aâ€²[].

Find first mismatch index l.

Find last mismatch index r.

Expand left and right boundaries.

Print (l+1, r+1) (1-based).

ðŸ’» Code Implementation
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t; 
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<int> a(n), b(n);
        for (int i = 0; i < n; i++) cin >> a[i];
        for (int i = 0; i < n; i++) cin >> b[i];

        int l = -1, r = -1;

        // Step 1: Find first mismatch
        for (int i = 0; i < n; i++) {
            if (a[i] != b[i]) {
                l = i;
                break;
            }
        }

        // Step 2: Find last mismatch
        for (int i = n - 1; i >= 0; i--) {
            if (a[i] != b[i]) {
                r = i;
                break;
            }
        }

        // Step 3: Expand both sides
        while (l > 0 && b[l - 1] <= b[l]) l--;
        while (r + 1 < n && b[r] <= b[r + 1]) r++;

        cout << l + 1 << " " << r + 1 << "\n";
    }
}

ðŸ§© Dry Run Example
Example 1
a  = [6, 7, 3, 4, 4, 6, 5]
aâ€² = [6, 3, 4, 4, 7, 6, 5]

Index	a[i]	aâ€²[i]	Same?
1	6	6	âœ…
2	7	3	âŒ
3	3	4	âŒ
4	4	4	âœ…
5	4	7	âŒ
6	6	6	âœ…
7	5	5	âœ…

First mismatch â†’ l = 2

Last mismatch â†’ r = 5

Check expansion:

aâ€²[1]=6 â‰¤ aâ€²[2]=3 âŒ â†’ no expand left

aâ€²[5]=7 â‰¤ aâ€²[6]=6 âŒ â†’ no expand right

âœ… Final Answer: (2, 5)

Example 2
a  = [1, 2, 1]
aâ€² = [1, 1, 2]


Mismatch at positions 2 and 3.

l = 2, r = 3

Expand:

left â†’ aâ€²[1]=1 â‰¤ aâ€²[2]=1 âœ… â†’ l = 1

right â†’ no expand

âœ… Final Answer: (1, 3)

Example 3
a  = [2, 2, 1]
aâ€² = [2, 1, 2]


Mismatch:

l = 2

r = 3

Expand:

aâ€²[1]=2 â‰¤ aâ€²[2]=1 âŒ â†’ no expand left

aâ€²[3]=2 â†’ last â†’ stop

âœ… Final Answer: (2, 3)

ðŸ§® Time Complexity

Each test case â†’ O(n)

Total sum of n â‰¤ 2Ã—10âµ
âœ… Efficient for given constraints.

ðŸ’¡ Important Observations

Matching indices can exist inside [l..r] â€” sorting still affects them.

Expanding based on sorted order in aâ€² ensures you get the longest possible valid subarray.

The approach is deterministic and minimal â€” works even for edge cases.

ðŸ Final Tips

Always compare a and aâ€² index by index to find mismatches.

Use 1-based indices in final output.

Be careful with array bounds when expanding l and r.

Test your solution with:

Already sorted cases.

Duplicate values.

Small n (like 2 or 3).

âœ… Summary Table
Step	What to do	Purpose
1	Find first mismatch l	Start of sorted subarray
2	Find last mismatch r	End of sorted subarray
3	Expand left/right	Ensure longest valid region
4	Output l+1, r+1	Convert to 1-based
