ğŸ§  Problem Understanding â€” â€œB. 2D Travelingâ€
ğŸ“œ Story Summary
link: https://codeforces.com/problemset/problem/1869/B

There are n cities on a 2D plane.

The first k cities are major cities (special cities).

Each city has coordinates (x, y).

You can fly between any two cities.

The flight cost f(i, j) is:

0                             if both i and j are major cities
|xi - xj| + |yi - yj|         otherwise  (Manhattan distance)


You start at city a and want to reach city b.
You can visit any number of intermediate cities.

You must find the minimum total flight cost to reach from a to b.

âš™ï¸ Key Observations

Free travel between major cities
â†’ All k major cities are mutually connected with cost = 0.

For any non-major city, traveling to a major city costs the Manhattan distance.

So the cheapest path can only be:

Directly from a â†’ b, or

a â†’ nearest major city + b â†’ nearest major city (since teleport among major cities is free).

ğŸ’¡ Derived Formula

Let:

dist(a, b) = |xa âˆ’ xb| + |ya âˆ’ yb|

mina = min distance from city a to any major city

minb = min distance from city b to any major city

Then the minimum cost is:

ans = min(dist(a, b), mina + minb)


Because:

Option 1: Fly directly (cost = dist(a, b))

Option 2: Go from a â†’ major1 â†’ major2 â†’ b (cost = mina + 0 + minb)

ğŸ§© Edge Case

If k == 0 (no major cities),
â†’ Only direct flight is possible:
ans = dist(a, b)

ğŸ§® Time Complexity

Each test case: O(k)

Total across all test cases: O(Î£k) â‰¤ 2Ã—10âµ âœ…
â†’ Works comfortably within 1s.

âœ… Final Code (Clean + Optimized)
#include <bits/stdc++.h>
using namespace std;

// ---------- FAST I/O ----------
#define fast_io ios::sync_with_stdio(false); cin.tie(nullptr);

// ---------- SHORTCUTS ----------
#define ll long long
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define endl '\n'

// ---------- CONSTANTS ----------
const ll INF = 1e18;

// ---------- SOLVE FUNCTION ----------
void solve() {
    ll n, k, a, b;
    cin >> n >> k >> a >> b;
    vector<pair<ll, ll>> v(n);
    for (int i = 0; i < n; i++) {
        cin >> v[i].first >> v[i].second;
    }

    a--; b--; // convert to 0-based indexing

    // Direct distance
    ll direct = abs(v[a].first - v[b].first) + abs(v[a].second - v[b].second);

    // No major cities -> direct flight only
    if (k == 0) {
        cout << direct << endl;
        return;
    }

    // Find nearest major city to a and b
    ll mina = INF, minb = INF;
    for (int i = 0; i < k; i++) {
        mina = min(mina, abs(v[i].first - v[a].first) + abs(v[i].second - v[a].second));
        minb = min(minb, abs(v[i].first - v[b].first) + abs(v[i].second - v[b].second));
    }

    // Result
    ll ans = min(direct, mina + minb);
    cout << ans << endl;
}

// ---------- MAIN ----------
int main() {
    fast_io
    int t;
    cin >> t;
    while (t--) solve();
    return 0;
}

ğŸ§© Example Walkthrough

Input

1
6 2 3 5
0 0
1 -2
-2 1
-1 3
2 -2
-3 -3


Step-by-step

Major cities: (0,0), (1,-2)
a = 3 â†’ (-2,1)
b = 5 â†’ (2,-2)

direct = |(-2)-2| + |1-(-2)| = 4 + 3 = 7

nearest major to a:
â†’ min(|(-2)-0|+|1-0|=3, |(-2)-1|+|1-(-2)|=6) = 3
nearest major to b:
â†’ min(|2-0|+|(-2)-0|=4, |2-1|+|(-2)-(-2)|=1) = 1

=> mina + minb = 3 + 1 = 4
=> answer = min(7, 4) = 4 âœ…


Output

4

ğŸ§­ Concept Summary (for your notes)
Concept	Meaning
Major cities	Connected freely (cost 0)
Manhattan distance	
Key formula	min(direct, mina + minb)
Time Complexity	O(k) per test
Edge Case	k = 0 â†’ only direct flight
