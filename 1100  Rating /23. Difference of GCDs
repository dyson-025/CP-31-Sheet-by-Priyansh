ğŸ§¾ Problem: Difference of GCDs
You are given:
link: https://codeforces.com/contest/1708/problem/B
Three integers n, l, r.

You must construct an array:
ğ‘1,ğ‘2,...,ğ‘ğ‘›a1,a2,...,an
	such that:

ğ‘™â‰¤ğ‘ğ‘–â‰¤ğ‘Ÿlâ‰¤aiâ‰¤r

All values 
ğ‘”ğ‘ğ‘‘(ğ‘–,ğ‘ğ‘–)
gcd(i,ai) are distinct

If possible â†’ print

YES
a1 a2 ... an


Otherwise â†’

NO

ğŸ§  Core Idea

We want all gcd(i, aáµ¢) to be different.

ğŸ‘‰ The simplest way to guarantee distinct gcds:

ğ‘”ğ‘ğ‘‘(ğ‘–,ğ‘ğ‘–)=ğ‘–gcd(i,ai)=i

Because all i = 1, 2, â€¦, n are distinct.

To make that true:

ğ‘ğ‘–
Â mustÂ beÂ aÂ multipleÂ ofÂ 
ğ‘–ai
	â€‹

Â mustÂ beÂ aÂ multipleÂ ofÂ i
âš™ï¸ Construction Formula

We need to pick a multiple of i that lies in [l, r].

âœ… The smallest multiple of i thatâ€™s â‰¥ l is:

In code:
a[i] = ((l + i - 1) / i) * i;


Then:

If a[i] > r, â†’ âŒ No valid number exists â†’ print NO

Else, continue

ğŸ§® Example 1
n = 5, l = 1, r = 5

i	aáµ¢ = ((l+i-1)/i)*i	gcd(i, aáµ¢)
1	1	1
2	2	2
3	3	3
4	4	4
5	5	5

âœ… gcds = [1,2,3,4,5] â€” distinct
âœ… all aáµ¢ in [1,5]
â†’ Output:

YES
1 2 3 4 5

ğŸ§® Example 2
n = 10, l = 30, r = 35

i	smallest multiple â‰¥30	in range?
1	30	âœ…
2	30	âœ…
3	30	âœ…
4	32	âœ…
5	30	âœ…
6	30	âœ…
7	35	âœ…
8	32	âœ…
9	36 âŒ	âŒ

âŒ i=9 fails â†’ print NO

âœ… Final Code
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    cin >> t;
    while (t--) {
        long long n, l, r;
        cin >> n >> l >> r;
        vector<long long> a(n + 1);
        bool ok = true;

        for (long long i = 1; i <= n; i++) {
            long long x = ((l + i - 1) / i) * i;  // smallest multiple of i >= l
            if (x > r) {
                ok = false;
                break;
            }
            a[i] = x;
        }

        if (!ok) {
            cout << "NO\n";
        } else {
            cout << "YES\n";
            for (int i = 1; i <= n; i++) cout << a[i] << " ";
            cout << "\n";
        }
    }
}

ğŸ§© Why This Works

Each index i gets a multiple of itself â†’ gcd(i, aáµ¢) = i

All i are distinct â†’ gcds are distinct

If any aáµ¢ canâ€™t fit in [l, r], itâ€™s impossible

â±ï¸ Complexity
Operation	Complexity
Per test case	O(n)
Total (âˆ‘n â‰¤ 1e5)	âœ… OK
Memory	O(n)
âš ï¸ Common Mistakes to Avoid
Mistake	Why Itâ€™s Wrong
Looping from i = l instead of 1	You lose the index relation in gcd(i, aáµ¢)
Checking duplicates of a[i]	Unnecessary â€” duplicates are fine
Trying to find next multiple manually	Not needed â€” smallest multiple formula handles it
Forgetting to check x > r	Causes invalid answers
Using int for large l, r (up to 1e9)	Use long long to prevent overflow
ğŸ§± Edge Cases
Case	Example	Output
Minimum	n=1, l=1, r=1	YES, [1]
Large range	n=5, l=1, r=1e9	always YES
Tight range	n=5, l=10, r=12	might be NO if some multiple >12
ğŸ’¡ Key Takeaways

âœ… Always loop over i = 1..n (indices matter in gcd).
âœ… Pick smallest multiple of i â‰¥ l.
âœ… Check if â‰¤ r.
âœ… Duplicates in aáµ¢ donâ€™t matter.
âœ… Distinct gcds are automatically ensured.

ğŸ”¥ In One Line

For each i (1..n), choose
a[i] = ((l + i - 1) / i) * i
â†’ if any a[i] > r â†’ NO else YES.
