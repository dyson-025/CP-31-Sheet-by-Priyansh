üß† Problem Summary
LINK: https://codeforces.com/contest/1904/problem/B
You‚Äôre given an array a of n positive integers.

You pick one element a[i], set your score = a[i].

Then, as long as your score ‚â• some element x,
you can remove x, increase your score by x, and repeat.

For each index i, find how many additional elements you can remove
if you start with score = a[i].

‚ö° Core Idea

If we sort the array in increasing order,
then the ‚Äúcollecting‚Äù process becomes monotonic ‚Äî
you‚Äôll always collect smaller elements first.

We can then determine, for each element, how far (to the right)
you can go after combining everything smaller than or equal to it.

üß© Step-by-step Logic (as in your code)
Step 1 ‚Äî Sort with indices
vector<pair<ll,ll>> v(n);
for (int i = 0; i < n; i++) {
    v[i].first = arr[i];
    v[i].second = i + 1;  // store original index
}
sort(v.begin(), v.end());


‚û°Ô∏è Sorting helps simulate collecting from smallest ‚Üí largest.

Step 2 ‚Äî Prefix Sum
vector<ll> pf(n);
pf[0] = v[0].first;
for (int i = 1; i < n; i++)
    pf[i] = pf[i-1] + v[i].first;


‚û°Ô∏è pf[i] = total of first (i+1) smallest elements.
This will help decide if the sum of smaller elements is big enough to ‚Äúcollect‚Äù the next one.

Step 3 ‚Äî Calculate Reachable Range from Right to Left
vector<ll> ans(n + 1);
ans[v[n-1].second] = n - 1;
for (int i = n - 2; i >= 0; i--) {
    if (pf[i] >= v[i + 1].first)
        ans[v[i].second] = ans[v[i + 1].second];
    else
        ans[v[i].second] = i;
}


Let‚Äôs break it down üëá

Case 1Ô∏è‚É£: pf[i] >= v[i+1].first

Meaning:
‚ÄúSum of all elements up to index i is enough to reach the next one.‚Äù

So, this element v[i] can also collect everything the next one can.

Hence:

ans[v[i].second] = ans[v[i+1].second];


‚Üí Both belong to the same collectable cluster.

Case 2Ô∏è‚É£: pf[i] < v[i+1].first

Meaning:
‚ÄúEven if you take all smaller elements, you still can‚Äôt reach the next value.‚Äù

So, this marks a new cluster boundary.

ans[v[i].second] = i;

Step 4 ‚Äî Output
for (int i = 1; i <= n; i++) cout << ans[i] << " ";
cout << endl;


Here,
ans[i] = index (in sorted array) of the last element you can collect.
So the value itself represents ‚Äúhow many total elements you can take - 1‚Äù (excluding yourself).

ü™∂ Intuitive Meaning

Imagine the sorted array as rising hills üåÑ.
You start on a hill v[i].
If the sum of everything behind you is enough to ‚Äúclimb‚Äù the next hill,
you merge into a larger hill group.
Otherwise, you start a new hill group.

At the end, every element‚Äôs ans tells which ‚Äúhill group‚Äù it belongs to.
All elements in the same group can reach the same maximum right endpoint.

üßÆ Example
a = [20, 5, 1, 4, 2]


Sorted:

v = [(1,3), (2,5), (4,4), (5,2), (20,1)]
pf = [1, 3, 7, 12, 32]


Processing from right ‚Üí left:

i	v[i]	pf[i]	v[i+1]	pf[i] ‚â• next?	ans
4	(20,1)	32	‚Äî	‚Äî	ans[1] = 4
3	(5,2)	12	20	‚ùå	ans[2] = 3
2	(4,4)	7	5	‚úÖ	ans[4] = ans[2] = 3
1	(2,5)	3	4	‚ùå	ans[5] = 1
0	(1,3)	1	2	‚ùå	ans[3] = 0

Final (in original order):

ans = [4, 3, 0, 3, 1]


‚úÖ Matches sample output.

‚öôÔ∏è Complexity
Step	Time
Sorting	O(n log n)
Prefix Sum	O(n)
Reverse Pass	O(n)
Total	O(n log n)
üß≠ Key Takeaways

Sorting makes the "collecting" process linear and predictable.

Prefix sum lets you test if total ‚Äúscore‚Äù can reach the next element.

Reverse pass merges ranges efficiently (like DSU logic).

ans[i] represents the farthest point that element can reach when collecting.

‚úÖ One-line Intuition:

‚ÄúIf the sum of all smaller elements ‚â• the next value, merge the groups; otherwise, start a new one.‚Äù
