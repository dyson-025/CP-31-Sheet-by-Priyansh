🧩 Problem Summary
link: https://codeforces.com/problemset/problem/1899/C
We are given an array a of n integers.
We must find the maximum sum of a non-empty subarray such that adjacent elements have alternating parity (odd-even-odd-even… or even-odd-even-odd…).

You can start anywhere in the array.

You can stop anywhere, but inside the subarray, adjacent numbers must alternate in parity.

📘 Example
a = [1, 2, 3, 4, 5]


✅ Allowed: [1, 2, 3, 4, 5] → all alternate parity
Sum = 15

❌ Not allowed: [2, 4] → both even

So answer = 15

⚙️ Core Idea (Kadane’s Algorithm with a Twist)

We want maximum alternating subarray sum.

Normally, Kadane’s Algorithm says:

dp[i] = max(a[i], dp[i-1] + a[i])

But here, we can only continue from previous element if parities alternate.

So:

dp[i] = a[i]                // start new subarray
if parity(a[i]) != parity(a[i-1]):
    dp[i] = max(dp[i], dp[i-1] + a[i])


Then:

answer = max(dp[i]) for all i

🧮 Step-by-step Dry Run
Example 1:
a = [1, 2, 3, 4, 5]

i	a[i]	parity	dp[i]	Explanation
0	1	odd	1	start
1	2	even	1+2=3	alternate with 1
2	3	odd	3+3=6	alternate with 2
3	4	even	6+4=10	alternate with 3
4	5	odd	10+5=15	alternate with 4

✅ Max = 15

Example 2:
a = [9, 9, 8, 8]

i	a[i]	parity	dp[i]	Explanation
0	9	odd	9	start
1	9	odd	9	same parity → start new
2	8	even	9+8=17	alternate with 9
3	8	even	8	same parity → restart

✅ Max = 17

Example 3:
a = [-1, 4, -1, 0, 5, -4]

i	a[i]	parity	dp[i]	Reason
0	-1	odd	-1	start
1	4	even	-1+4=3	alt
2	-1	odd	3+(-1)=2	alt
3	0	even	2+0=2	alt
4	5	odd	2+5=7	alt
5	-4	even	7+(-4)=3	alt

✅ Max = 7
But we can also take subarray [4, -1, 0, 5] = 8 → answer = 8

🔁 General Algorithm (Efficient O(n))
#include <bits/stdc++.h>
using namespace std;
#define int long long

bool parity(int x) { return x % 2; }

int solve(vector<int>& a) {
    int n = a.size();
    vector<int> dp(n);
    dp[0] = a[0];
    int ans = a[0];

    for (int i = 1; i < n; i++) {
        dp[i] = a[i];
        if (parity(a[i]) != parity(a[i - 1]))
            dp[i] = max(dp[i], dp[i - 1] + a[i]);
        ans = max(ans, dp[i]);
    }
    return ans;
}

int32_t main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int t; cin >> t;
    while (t--) {
        int n; cin >> n;
        vector<int> a(n);
        for (int i = 0; i < n; i++) cin >> a[i];
        cout << solve(a) << "\n";
    }
}

🧠 Key Observations

Only alternate parities can continue — if not, restart subarray.

Works like Kadane’s, but with parity condition.

Handles negative numbers — since we always take max between starting new or continuing.

Time: O(n) per test
Space: O(1) if we optimize.

💡 Space-optimized version

We don’t need full dp array:

int solve(vector<int>& a) {
    int ans = a[0], prev = a[0];
    for (int i = 1; i < a.size(); i++) {
        if ((a[i] % 2 + 2) % 2 != (a[i-1] % 2 + 2) % 2)
            prev = max(a[i], prev + a[i]);
        else
            prev = a[i];
        ans = max(ans, prev);
    }
    return ans;
}

🧭 Diagram (Concept)
Array:  1   2   3   4   5
Parity: O   E   O   E   O
         ↘ ↗ ↘ ↗ ↘ (alternating)
Sum grows continuously
Max sum = 15

✅ Final Answers from Examples
Test	Array	Output
1	[1, 2, 3, 4, 5]	15
2	[9, 9, 8, 8]	17
3	[-1, 4, -1, 0, 5, -4]	8
4	[-1, 2, 4, -3]	4
5	[-1000]	-1000
6	[101, -99, 101]	101
7	[-10, 5, -8, 10, 6, -10, 7, 9, -2, -6, 7, 2, -4, 6, -1, 7, -6, -7, 4, 1]	10
