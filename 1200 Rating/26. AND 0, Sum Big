ğŸ“˜ Problem Summary
link: https://codeforces.com/problemset/problem/1514/B
Given two integers n and k, find the number of arrays of length n such that:

Each element is in the range [0, 2^k âˆ’ 1]

The bitwise AND of all elements is 0

The sum of elements is as large as possible

Return the answer mod (10â¹ + 7).

âš™ï¸ Key Concepts
1ï¸âƒ£ Bitwise AND = 0 Condition

For an arrayâ€™s AND to be 0,
every bit position (from 0 to kâˆ’1) must have at least one element with that bit = 0.

2ï¸âƒ£ Maximum Sum Condition

The largest element possible = 2^k âˆ’ 1 (all bits = 1).

But if all are 2^k âˆ’ 1 â†’ AND = 2^k âˆ’ 1 âŒ

To make AND = 0, we must turn off (set 0) at least one bit somewhere in the array for every bit position.

Turning off only one bit per position keeps the sum maximum.

3ï¸âƒ£ Counting the Possibilities

Each bit position is independent.

For each of the k bits:
we can choose which element (among n) will have that bit = 0.

Therefore, for every bit â†’ n choices.

âœ… Total Ways
TotalÂ arrays
=
ğ‘›
ğ‘˜
TotalÂ arrays=n
k

Since the result can be huge:

Answer=(n
k
)mod(10
9
+7)
ğŸ§® Example

Input:

2
2 2
100000 20


Case 1: n = 2, k = 2
â†’ Each bit has 2 choices â†’ total = 2Â² = 4 âœ…

Case 2: n = 100000, k = 20
â†’ (100000Â²â°) mod 1e9+7 = 226732710 âœ…

ğŸ§¾ Code Explanation
#include <bits/stdc++.h>
using namespace std;
const int mod = 1e9 + 7;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int t;
    cin >> t;
    while (t--) {
        long long n, k;
        cin >> n >> k;
        long long ans = 1;
        for (int i = 0; i < k; i++) {
            ans *= n;        // multiply by n each bit
            ans %= mod;      // modulo to avoid overflow
        }
        cout << ans << "\n"; // print (n^k % mod)
    }
}

ğŸ” Working

The loop multiplies n exactly k times â†’ computes n^k.

Each step uses % mod to prevent overflow.

Time Complexity: O(k) (since k â‰¤ 20, this is trivial).

Space Complexity: O(1).

ğŸ’¡ Intuition Summary
Concept	Meaning
Every bit position	Needs at least one 0 to make AND = 0
Each bit	Can choose any of n elements to place the 0
Independent bits	Multiply the possibilities
Hence	
ğ‘›
ğ‘˜
n
k
 total arrays
Final step	Take result mod 1e9 + 7
ğŸ§  Formula Recap

Answer=(n
k
)mod(10
9
+7)
	â€‹

âœï¸ Quick Revision Points

AND = 0 â†’ each bit position must contain at least one 0.

Max sum â†’ make all bits 1 except one 0 per bit position.

Each bit â†’ n choices, so total = n^k.

Take modulo 1e9+7 for large numbers.

Efficient method â†’ modular exponentiation (or simple loop since k â‰¤ 20).
