ğŸ§© Problem Summary â€” â€œCat Cycleâ€
link: https://codeforces.com/problemset/problem/1487/B
We have two cats: A and B, and n spots arranged in a circle.

Movement Rules:

Cat A moves backward cyclically:

n, n-1, n-2, ..., 2, 1, n, n-1, ...


Cat B moves forward cyclically:

1, 2, 3, ..., n-1, n, 1, 2, ...

Rule of Conflict:

If both cats want the same spot, Cat A gets it (since A is older),
and Cat B moves to the next spot in its increasing order.

ğŸ§  Whatâ€™s Asked

We must determine which spot Cat B is on after k hours.

âš™ï¸ Example Walkthrough

Letâ€™s understand with small examples first.

Example 1:
n = 2, k = 1
Aâ€™s order: 2, 1, 2, 1, ...
Bâ€™s order: 1, 2, 1, 2, ...


At hour 1:

A â†’ spot 2

B â†’ spot 1
âœ… So, answer = 1

At hour 2:

A â†’ spot 1

B â†’ wants 2 â†’ not occupied â†’ sits on 2
âœ… So, answer = 2

Example 2:
n = 3
Aâ€™s order: 3, 2, 1, 3, 2, 1, ...
Bâ€™s order: 1, 2, 3, 1, 2, 3, ...


Hour 1:

A â†’ 3

B â†’ 1
âœ… no clash â†’ B = 1

Hour 2:

A â†’ 2

B â†’ wants 2, but A is there â†’ moves to next spot (3)
âœ… B = 3

Hour 3:

A â†’ 1

B â†’ wants 1, but A is there â†’ moves to next (2)
âœ… B = 2

So, the pattern for B (n=3):
1, 3, 2, 1, 3, 2, ...

ğŸ“Š Pattern Observation

When n is even:
There is no extra shift for B â€” both cats complete full cycles in sync.
So Cat Bâ€™s position is just (k % n).

When n is odd:
Thereâ€™s an extra shift every n/2 hours.

Why?
Because when n is odd, both cats will collide once in every half cycle.
This forces Cat B to move one step ahead extra each time that happens.

ğŸ“ Mathematical Formula Derivation

Letâ€™s analyze this carefully.

Case 1: n is even

âœ… They never clash periodically.
So Cat Bâ€™s position is simple:

B_pos=(kâˆ’1)modn+1
Case 2: n is odd

Letâ€™s define:

mid = n / 2 (integer division)

Every mid hours, B gets pushed one step further because of conflicts.

Hence, in k hours:

The number of â€œpushesâ€ B faced = k / mid (integer division)

So total extra shifts = k / mid

Thus the formula becomes:

B_pos=((kâˆ’1)+âŒŠ(kâˆ’1)/midâŒ‹)modn+1
ğŸ§© Final Code Explanation (line by line)
#include <bits/stdc++.h>
using namespace std;
#define ll long long


â†’ Includes all standard headers and defines long long as ll.

int main() {
    int t;
    cin >> t;


â†’ Input number of test cases.

    while (t--) {
        int n, k;
        cin >> n >> k;
        k--; // convert to 0-based indexing for easier modulo calculation


â†’ Decrement k by 1 to make it zero-based (since hour 1 corresponds to index 0).

Case 1: Even n
        if (n % 2 == 0) {
            int ans = (k % n);
            cout << ans + 1 << "\n";
        }


â†’ For even n, thereâ€™s no extra shift.
â†’ Just print (k % n) + 1.

Case 2: Odd n
        else {
            int mid = n / 2;
            int ans = ((k / mid) + k) % n;
            cout << ans + 1 << "\n";
        }


â†’ For odd n, calculate the number of extra shifts: k / mid.
â†’ Add this to k, take modulo n, then add 1 (convert back to 1-based).

âœ… Example Verification

Input:

7
2 1
2 2
3 1
3 2
3 3
5 5
69 1337


Output:

1
2
1
3
2
2
65


Letâ€™s check one:
n = 5, k = 5

mid = 2

shifts = k/mid = 5/2 = 2

ans = (5-1 + 2) % 5 + 1 = (4+2)%5+1 = 6%5+1 = 2
âœ… matches output (2)

ğŸ” Intuitive Summary
Type of n	Behavior	Formula for Bâ€™s Position (1-based)
Even	No extra shifts	(k-1) % n + 1
Odd	Every n/2 hours â†’ +1 shift	((k-1) + floor((k-1)/(n/2))) % n + 1
ğŸ–Šï¸ Key Notes for Exam / Contest Revision

Always convert k to 0-based before modulo math.

Even case = simple circular movement.

Odd case = one extra step shift every mid steps.

This question tests pattern detection, modular arithmetic, and simulation optimization (since n, k â‰¤ 1e9).
