link: https://codeforces.com/problemset/problem/1420/B
ðŸ§¾ Detailed Notes â€“ B. Rock and Lever
ðŸ“˜ Problem Statement

You are given an integer n and an array a[1â€¦n].
You must count the number of pairs (i, j) (where i < j) such that:

ð‘Žð‘–&ð‘Žð‘—â‰¥ð‘Žð‘–âŠ•ð‘Žð‘—ai	â€‹&aj	â€‹â‰¥aiâŠ•aj
	â€‹
where

& â†’ bitwise AND

âŠ• â†’ bitwise XOR

ðŸ“Š Input / Output Format
Input:
t â€” number of test cases
n â€” array size
a1, a2, â€¦, an â€” array elements

Output:

For each test case, output the count of valid pairs.

ðŸ’­ Understanding the Condition

We need pairs (a_i, a_j) such that:

ð‘Žð‘–&ð‘Žð‘—â‰¥ð‘Žð‘–âŠ•ð‘Žð‘—ai	â€‹&aj	â€‹â‰¥ai	â€‹âŠ•aj
	â€‹
Let's check what this means using examples ðŸ‘‡

Example 1
a_i = 4 (100)
a_j = 7 (111)


a_i & a_j = 100 = 4

a_i âŠ• a_j = 011 = 3
âœ… 4 â‰¥ 3 â†’ valid pair

Example 2
a_i = 5 (101)
a_j = 2 (010)


a_i & a_j = 000 = 0

a_i âŠ• a_j = 111 = 7
âŒ 0 â‰¥ 7 â†’ invalid

ðŸ§  Observation

The inequality a_i & a_j â‰¥ a_i âŠ• a_j holds only if both numbers have the same most significant bit (MSB).

Letâ€™s confirm ðŸ‘‡

Example 1
a_i = 6 (110)
a_j = 5 (101)
MSB of both = bit position 2


a_i & a_j = 100 = 4

a_i âŠ• a_j = 011 = 3
âœ… holds

Example 2
a_i = 4 (100)
a_j = 3 (011)
MSB differ â†’ âŒ fails


âœ… Conclusion:
Condition holds if and only if both numbers have the same MSB position.

âš™ï¸ Simplified Problem

So now our task reduces to:

Count the number of pairs (i, j) such that both numbers have the same MSB.

ðŸ§® Step-by-Step Solution

1ï¸âƒ£ For each number a[i], find its most significant set bit position.
2ï¸âƒ£ Group numbers by their MSB position.
3ï¸âƒ£ For each group of size k, the number of valid pairs =

ð‘˜â‹…(ð‘˜âˆ’1)22kâ‹…(kâˆ’1)
	â€‹


4ï¸âƒ£ Sum across all groups.

ðŸ§© Example Walkthrough
n = 5
a = [1, 4, 3, 7, 10]

a[i]	Binary	MSB Position
1	0001	0
4	0100	2
3	0011	1
7	0111	2
10	1010	3

Groups by MSB:

bit 0 â†’ [1]

bit 1 â†’ [3]

bit 2 â†’ [4, 7]

bit 3 â†’ [10]

Only bit 2 group has 2 elements
â†’ pairs = 2C2 = 1

âœ… Answer = 1

ðŸ’» Final Code (Using Built-in MSB)
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<int> a(n);
        for (int i = 0; i < n; i++) cin >> a[i];

        map<int, long long> freq;

        for (int x : a) {
            int msb = 31 - __builtin_clz(x);  // find most significant bit
            freq[msb]++;
        }

        long long ans = 0;
        for (auto [bit, cnt] : freq) {
            ans += (cnt * (cnt - 1)) / 2;
        }

        cout << ans << "\n";
    }
}

ðŸ§® Time and Space Complexity
Complexity	Value
Time	O(n) per test case
Space	O(32) â†’ constant space

Efficient for n â‰¤ 10^5.

ðŸ”§ When You Donâ€™t Remember Built-in MSB Function

If you donâ€™t remember __builtin_clz(),
you can calculate MSB position manually in several ways ðŸ‘‡

ðŸ§® Method 1 â€“ Bit Shift Loop
int getMSBPos(int x) {
    int pos = 0;
    while (x > 1) {
        x >>= 1;
        pos++;
    }
    return pos;  // 0-indexed (LSB = 0)
}


Example:
x = 20 (10100)
â†’ pos = 4

ðŸ§® Method 2 â€“ Using log2 (Math Trick)
#include <cmath>
int getMSBPos(int x) {
    return (int)log2(x);
}


Example:
x = 20 â†’ log2(20) â‰ˆ 4.32 â†’ MSB = 4

ðŸ§® Method 3 â€“ Binary Search Bit Trick

Fastest manual method (no loops):

int getMSBPos(int x) {
    int pos = 0;
    if (x >= (1 << 16)) { x >>= 16; pos += 16; }
    if (x >= (1 << 8))  { x >>= 8;  pos += 8; }
    if (x >= (1 << 4))  { x >>= 4;  pos += 4; }
    if (x >= (1 << 2))  { x >>= 2;  pos += 2; }
    if (x >= (1 << 1))  { pos += 1; }
    return pos;
}

âœ… Using Any of These in the Main Code

Replace this:

int msb = 31 - __builtin_clz(x);


With:

int msb = getMSBPos(x);


Rest of the logic remains same.

ðŸ’» Full Code Without Built-in Functions
#include <bits/stdc++.h>
using namespace std;

int getMSBPos(int x) {
    int pos = 0;
    while (x > 1) {
        x >>= 1;
        pos++;
    }
    return pos;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<int> a(n);
        for (int i = 0; i < n; i++) cin >> a[i];

        map<int, long long> freq;
        for (int x : a) {
            int msb = getMSBPos(x);
            freq[msb]++;
        }

        long long ans = 0;
        for (auto [bit, cnt] : freq)
            ans += (cnt * (cnt - 1)) / 2;

        cout << ans << "\n";
    }
}

ðŸ§  Concept Recap
Concept	Description
Condition	a_i & a_j â‰¥ a_i âŠ• a_j
Holds When	a_i and a_j have the same most significant bit
Solution Idea	Group numbers by MSB
Formula	Pairs = k Ã— (kâˆ’1) / 2 per group
Built-in	__builtin_clz(x)
Manual Methods	Shift loop, log2, bit trick
ðŸ”‘ Key Takeaways

âœ… Condition depends only on MSB equality
âœ… Use frequency counting by MSB position
âœ… 3 ways to find MSB (choose any)
âœ… Total pairs = sum of combinations inside each group
âœ… O(n) solution â†’ perfect for large constraints
