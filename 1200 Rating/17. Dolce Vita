ğŸ§  Problem Understanding
link: https://codeforces.com/problemset/problem/1671/C
You have:

n shops.

Each shop i sells 1 pack of sugar per day.

On day d, price of shop i = a[i] + (d - 1).

You have a daily budget x.
Each day you buy as many packs as possible (sum â‰¤ x).
You repeat this for as many days as possible.

We must find the total number of packs bought before you canâ€™t buy anything.

ğŸ” Key Observation

Prices increase by +1 per day for every shop.
So instead of simulating day by day (which would be huge), we can find how many days we can buy a certain prefix of shops.

ğŸ§© Step 1: Sort the Prices

We sort a in ascending order â†’ always buy the cheapest first.

Let prefix[i] = a[0] + a[1] + ... + a[i]
â†’ sum of cheapest (i+1) shops initially.

ğŸ§© Step 2: When can we buy these (i+1) shops?

On day d, total cost =
(prefix[i]) + (i+1)*(d - 1)

Because every shop price increases by 1 each day.

We can keep buying these (i+1) packs as long as:

prefix[i] + (i+1)*(d - 1) â‰¤ x


Solve for d:

d â‰¤ (x - prefix[i]) / (i + 1) + 1


The number of valid days =
max_day = (x - prefix[i]) / (i + 1) (since day starts from 1)

ğŸ§® Step 3: Count total packs

If you can buy (i+1) packs for max_day days,
that contributes:

total += (max_day) * (i + 1)


We sum this over all prefixes i such that prefix[i] â‰¤ x.

ğŸ§  Step 4: Stop Condition

Once prefix[i] > x,
â†’ canâ€™t even buy (i+1) packs on day 1, so stop.

âœ… Step 5: Complexity

Sorting: O(n log n)

Prefix + Loop: O(n)

Total over testcases â‰¤ 2Ã—10âµ â†’ fully fine.

ğŸ’¡ Example Walkthrough

Example:

n = 3, x = 7
a = [2, 1, 2]


Sorted: [1, 2, 2]

i	prefix[i]	(i+1)	(x - prefix[i]) / (i+1)	Days	Packs bought
0	1	1	(7-1)/1=6	6 days	6*1 = 6
1	3	2	(7-3)/2=2	2 days	2*2 = 4
2	5	3	(7-5)/3=0	0 days	0
Total = 6 + 4 + 1 (day 1 for last shop) = 11 âœ…					
ğŸ’» C++ Code
#include <bits/stdc++.h>
using namespace std;
#define int long long

int32_t main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    int t;
    cin >> t;
    while (t--) {
        int n, x;
        cin >> n >> x;
        vector<int> a(n);
        for (int &v : a) cin >> v;

        sort(a.begin(), a.end());

        vector<int> prefix(n);
        prefix[0] = a[0];
        for (int i = 1; i < n; i++) prefix[i] = prefix[i - 1] + a[i];

        long long ans = 0;
        for (int i = 0; i < n; i++) {
            if (prefix[i] > x) break;
            long long days = (x - prefix[i]) / (i + 1);
            ans += days + 1;  // +1 because day count starts from 1
        }

        cout << ans << '\n';
    }
}

ğŸ§© Logic Summary (Short Notes)
Step	Idea	Formula
1	Sort prices	a.sort()
2	Prefix sum	prefix[i] = sum(a[0..i])
3	Feasible days	(x - prefix[i]) / (i + 1)
4	Total packs	ans += days + 1
5	Stop when	prefix[i] > x
ğŸ Final Intuition Recap

Each prefix of shops can be bought for several days until prices get too high.

Longer prefixes (more shops) stop earlier because they cost more.

Add up how many days each prefix remains affordable.

Thatâ€™s your total sugar packs.
