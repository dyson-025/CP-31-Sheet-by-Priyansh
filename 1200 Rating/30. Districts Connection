🧾 Detailed Notes – D. Districts Connection
 link: https://codeforces.com/problemset/problem/1433/D
📘 Problem Statement

There are n districts, each district belongs to some gang.

You need to build n−1 two-way roads such that:

All districts are reachable (connected graph / tree).

No directly connected districts belong to the same gang.

If possible → print "YES" and the list of roads.
Otherwise → print "NO".

📊 Input & Output Format
Input:
t                → number of test cases
n                → number of districts
a1, a2, ..., an  → gangs of each district

Output:

If possible:

YES
x1 y1
x2 y2
...
x(n-1) y(n-1)


Otherwise:

NO

🧠 Observations

To connect all districts, we need exactly n−1 roads (to form a tree).

The main restriction:

No road connects two districts with the same gang.


If all gangs are same, e.g.

a = [1, 1, 1, 1]


Then any road connects same gang → ❌ impossible.

If there exist at least two different gangs,
then we can always build such a tree ✅.

💭 Key Idea (The Trick)

We can use two types of districts (belonging to different gangs)
as “bridge” nodes to connect everyone.

Step 1:

Choose district 1 as reference (gang = a[1]).

Find the first district whose gang ≠ a[1].
Let’s call its index → diffIndex.

Example:

a = [1, 2, 2, 1, 3]
a[1] = 1
diffIndex = 2 (gang = 2)

Step 2:

Now, build connections as follows:

If a[i] ≠ a[1] → connect district i with district 1.

If a[i] = a[1] → connect district i with diffIndex.

This ensures:
✅ Every connection is between different gangs
✅ Every district gets connected either directly to 1 or indirectly through diffIndex
✅ We form a tree with n−1 edges

⚙️ Algorithm (Step-by-Step)

1️⃣ Read integer t (number of test cases).

2️⃣ For each test case:

Read n

Read array a[1..n]

3️⃣ Find diffIndex:

diffIndex = -1
for i = 2 to n:
    if a[i] != a[1]:
        diffIndex = i
        break


4️⃣ If no such diffIndex found → print "NO" and continue.

5️⃣ Otherwise:

Print "YES"

For each i from 2 to n:

If a[i] ≠ a[1] → print 1 i

Else → print diffIndex i

🧩 Example Walkthrough
Example 1:
n = 5
a = [1, 2, 2, 1, 3]


a[1] = 1

diffIndex = 2 (gang 2)

Now build:

i	a[i]	Action	Road
2	2	a[2] ≠ a[1]	(1, 2)
3	2	a[3] ≠ a[1]	(1, 3)
4	1	a[4] = a[1]	(2, 4)
5	3	a[5] ≠ a[1]	(1, 5)

✅ All connected
✅ Different gangs connected only
✅ 4 roads (n−1 = 4)

Output:

YES
1 2
1 3
2 4
1 5

Example 2:
n = 3
a = [1, 1, 1]


→ all same gangs → impossible

Output:

NO

💻 Final Code
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<int> a(n + 1);
        for (int i = 1; i <= n; i++) cin >> a[i];

        int diffIndex = -1;
        for (int i = 2; i <= n; i++) {
            if (a[i] != a[1]) {
                diffIndex = i;
                break;
            }
        }

        if (diffIndex == -1) {
            cout << "NO\n";
            continue;
        }

        cout << "YES\n";
        for (int i = 2; i <= n; i++) {
            if (a[i] != a[1])
                cout << 1 << " " << i << "\n";
            else
                cout << diffIndex << " " << i << "\n";
        }
    }
    return 0;
}

⏱️ Complexity Analysis
Type	Complexity
Time	O(n) per test case
Space	O(n)
Sum of n over test cases ≤ 5000 → very efficient ✅	
🧠 Conceptual Summary
Concept	Explanation
Graph Type	Tree (n−1 edges)
Condition	Adjacent nodes must have different gang IDs
Trick	Use 2 gang types as connectors
Impossible Case	All gangs are same
Construction	1 connects to all different, diffIndex connects to same
🧩 Pattern Recognition (for Future Problems)

This is a "connect with constraints" pattern problem.
When you see:

"Connect all nodes"

"No same values adjacent"
→ Think of finding two different elements and using them to form a spanning tree.

✅ Key Takeaways

If all gangs are same → ❌ NO

Else → always possible → ✅ YES

Use district 1 and first different as hubs.

Each node connects to one of these depending on gang.
