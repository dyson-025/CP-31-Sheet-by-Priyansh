ğŸ§® Problem: B. M-arrays
Statement

You are given an array a of length n and an integer m.
You must divide the elements into the minimum number of m-divisible arrays,
where an array is called m-divisible if for every pair of adjacent elements:

(ğ‘[ğ‘–]+ğ‘[ğ‘–+1])â€Šmodâ€Šğ‘š=0(a[i]+a[i+1])modm=0

An array of one element is automatically m-divisible.

We must find the smallest number of such arrays possible.

ğŸ§  Step 1: Reduce to remainders

Each element only matters by its remainder r = a[i] % m.

To form an m-divisible array:

(ğ‘Ÿ1+ğ‘Ÿ2)â€Šmodâ€Šğ‘š=0(r1	+r2)modm=0

That means each remainder r can be paired only with m âˆ’ r.

So remainders come in complementary pairs:

(1, mâˆ’1), (2, mâˆ’2), (3, mâˆ’3), â€¦


Special remainders:

0 pairs with itself â†’ all 0s can go in one array.

if m is even, then m/2 also pairs with itself â†’ all such elements can go in one array.

âš™ï¸ Step 2: Frequency map

Let cnt[r] = number of elements with remainder r.

We now have m buckets: 0 â€¦ mâˆ’1.

Our goal â†’ combine buckets (r, mâˆ’r) to minimize number of arrays.

ğŸ§© Step 3: Handling each pair

Consider one pair of complementary remainders (r, mâˆ’r):

Let

x = cnt[r]
y = cnt[mâˆ’r]


We can match up min(x, y) of them perfectly:

r + (mâˆ’r) = m â†’ divisible by m


These matched pairs can be in one array.

Now check whatâ€™s left:

Case 1. both 0

â†’ do nothing

Case 2. x = y > 0

â†’ all matched, so just 1 array needed
â‡’ ans += 1

Case 3. x â‰  y

â†’ some elements remain unmatched.
They canâ€™t attach to the other remainder anymore,
so each extra element becomes a new separate array.
â‡’ ans += |xâˆ’y|

ğŸ”µ Step 4: Special cases

Remainder 0
All elements with remainder 0 can form 1 array.

if (cnt[0] > 0) ans++;


Remainder m/2 (only when m is even)
All such elements can form 1 array.

if (m % 2 == 0 && cnt[m/2] > 0) ans++;


Remaining pairs
Iterate r = 1 â€¦ m/2, and process (r, mâˆ’r) once.

âœ… Final Formula / Algorithm
for each test case:
    read n, m
    make array cnt[m] = {0}
    for i in 1..n:
        cnt[a[i] % m]++
    ans = 0
    if cnt[0] > 0: ans++

    for r in [1 â€¦ m/2]:
        if (r == m - r):         // only when m even and r == m/2
            if cnt[r] > 0: ans++
        else:
            x = cnt[r]
            y = cnt[m - r]
            if x==0 && y==0: continue
            else if x==y: ans++
            else ans += abs(x - y)
    output ans


Time complexity â†’ O(n + m)
Space complexity â†’ O(m)

ğŸ§® Step 5: Dry Runs
Example 1
n=6, m=4
a = [2, 2, 8, 6, 9, 4]


Remainders:

2,2,0,2,1,0
cnt = [2,1,3,0]


remainder 0 â†’ +1 array

m even, m/2 = 2 â†’ +1 array

r=1, mâˆ’r=3 â†’ cnt[1]=1, cnt[3]=0 â†’ +|1âˆ’0| = +1

âœ… total = 3 â†’ matches sample output.

Example 2
m=2, a=[2,4]
remainders [0,0]
cnt=[2,0]
â†’ only remainder 0 present â†’ ans=1

Example 3
m=8
remainders counts:
r=1:4, r=7:2
r=3:1, r=5:1
r=0:3, r=4:2


Processing:

r=0 â†’ +1

(1,7): |4âˆ’2|=2 â†’ +2

(2,6): both 0 â†’ skip

(3,5): equal â†’ +1

r=4 (m/2) â†’ +1
Total = 1+2+1+1 = 5

âš ï¸ Step 6: Common Mistakes
Mistake	Why Wrong
Using loop condition r*r < m	Skips valid pairs for large m
Counting m/2 twice	When handled both before and inside loop
Forgetting to use long long	Overflow on large n, m
Using abs() (int) instead of llabs()	Incorrect for 64-bit counts
Not skipping zero counts	Adds wrong groups
âœ… Step 7: Final Clean Code
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t; cin >> t;
    while (t--) {
        int n, m;
        cin >> n >> m;
        vector<ll> cnt(m, 0);
        for (int i = 0; i < n; ++i) {
            ll x; cin >> x;
            cnt[x % m]++;
        }

        ll ans = 0;
        if (cnt[0] > 0) ans++;

        for (int r = 1; r <= m / 2; ++r) {
            int s = m - r;
            if (r == s) {                    // m even and r==m/2
                if (cnt[r] > 0) ans++;
            } else {
                ll x = cnt[r], y = cnt[s];
                if (x == 0 && y == 0) continue;
                else if (x == y) ans++;
                else ans += llabs(x - y);
            }
        }

        cout << ans << '\n';
    }
    return 0;
}

ğŸ“š Summary Sheet
Concept	Meaning
m-divisible	every adjacent pair sums to multiple of m
Key idea	use remainders mod m
Pair logic	combine (r, mâˆ’r)
Special cases	0 and m/2 (if even)
Complexity	O(n + m)
Final formula	ans = (0 bucket) + (m/2 bucket) + Î£ over pairs(min logic)
