🧮 Problem: B. M-arrays
Statement

You are given an array a of length n and an integer m.
You must divide the elements into the minimum number of m-divisible arrays,
where an array is called m-divisible if for every pair of adjacent elements:

(𝑎[𝑖]+𝑎[𝑖+1]) mod 𝑚=0(a[i]+a[i+1])modm=0

An array of one element is automatically m-divisible.

We must find the smallest number of such arrays possible.

🧠 Step 1: Reduce to remainders

Each element only matters by its remainder r = a[i] % m.

To form an m-divisible array:

(𝑟1+𝑟2) mod 𝑚=0(r1	+r2)modm=0

That means each remainder r can be paired only with m − r.

So remainders come in complementary pairs:

(1, m−1), (2, m−2), (3, m−3), …


Special remainders:

0 pairs with itself → all 0s can go in one array.

if m is even, then m/2 also pairs with itself → all such elements can go in one array.

⚙️ Step 2: Frequency map

Let cnt[r] = number of elements with remainder r.

We now have m buckets: 0 … m−1.

Our goal → combine buckets (r, m−r) to minimize number of arrays.

🧩 Step 3: Handling each pair

Consider one pair of complementary remainders (r, m−r):

Let

x = cnt[r]
y = cnt[m−r]


We can match up min(x, y) of them perfectly:

r + (m−r) = m → divisible by m


These matched pairs can be in one array.

Now check what’s left:

Case 1. both 0

→ do nothing

Case 2. x = y > 0

→ all matched, so just 1 array needed
⇒ ans += 1

Case 3. x ≠ y

→ some elements remain unmatched.
They can’t attach to the other remainder anymore,
so each extra element becomes a new separate array.
⇒ ans += |x−y|

🔵 Step 4: Special cases

Remainder 0
All elements with remainder 0 can form 1 array.

if (cnt[0] > 0) ans++;


Remainder m/2 (only when m is even)
All such elements can form 1 array.

if (m % 2 == 0 && cnt[m/2] > 0) ans++;


Remaining pairs
Iterate r = 1 … m/2, and process (r, m−r) once.

✅ Final Formula / Algorithm
for each test case:
    read n, m
    make array cnt[m] = {0}
    for i in 1..n:
        cnt[a[i] % m]++
    ans = 0
    if cnt[0] > 0: ans++

    for r in [1 … m/2]:
        if (r == m - r):         // only when m even and r == m/2
            if cnt[r] > 0: ans++
        else:
            x = cnt[r]
            y = cnt[m - r]
            if x==0 && y==0: continue
            else if x==y: ans++
            else ans += abs(x - y)
    output ans


Time complexity → O(n + m)
Space complexity → O(m)

🧮 Step 5: Dry Runs
Example 1
n=6, m=4
a = [2, 2, 8, 6, 9, 4]


Remainders:

2,2,0,2,1,0
cnt = [2,1,3,0]


remainder 0 → +1 array

m even, m/2 = 2 → +1 array

r=1, m−r=3 → cnt[1]=1, cnt[3]=0 → +|1−0| = +1

✅ total = 3 → matches sample output.

Example 2
m=2, a=[2,4]
remainders [0,0]
cnt=[2,0]
→ only remainder 0 present → ans=1

Example 3
m=8
remainders counts:
r=1:4, r=7:2
r=3:1, r=5:1
r=0:3, r=4:2


Processing:

r=0 → +1

(1,7): |4−2|=2 → +2

(2,6): both 0 → skip

(3,5): equal → +1

r=4 (m/2) → +1
Total = 1+2+1+1 = 5

⚠️ Step 6: Common Mistakes
Mistake	Why Wrong
Using loop condition r*r < m	Skips valid pairs for large m
Counting m/2 twice	When handled both before and inside loop
Forgetting to use long long	Overflow on large n, m
Using abs() (int) instead of llabs()	Incorrect for 64-bit counts
Not skipping zero counts	Adds wrong groups
✅ Step 7: Final Clean Code
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t; cin >> t;
    while (t--) {
        int n, m;
        cin >> n >> m;
        vector<ll> cnt(m, 0);
        for (int i = 0; i < n; ++i) {
            ll x; cin >> x;
            cnt[x % m]++;
        }

        ll ans = 0;
        if (cnt[0] > 0) ans++;

        for (int r = 1; r <= m / 2; ++r) {
            int s = m - r;
            if (r == s) {                    // m even and r==m/2
                if (cnt[r] > 0) ans++;
            } else {
                ll x = cnt[r], y = cnt[s];
                if (x == 0 && y == 0) continue;
                else if (x == y) ans++;
                else ans += llabs(x - y);
            }
        }

        cout << ans << '\n';
    }
    return 0;
}

📚 Summary Sheet
Concept	Meaning
m-divisible	every adjacent pair sums to multiple of m
Key idea	use remainders mod m
Pair logic	combine (r, m−r)
Special cases	0 and m/2 (if even)
Complexity	O(n + m)
Final formula	ans = (0 bucket) + (m/2 bucket) + Σ over pairs(min logic)
