ğŸ§© Problem Restatement
link: https://codeforces.com/problemset/problem/1497/B
We are given:

an array a1, a2, â€¦, an of positive integers

a positive integer m

We can divide the array into some number of subarrays (groups).
Each group should be m-divisible, meaning:

For every two adjacent numbers in that subarray, their sum is divisible by m.

Formally, if the array is [b1, b2, â€¦, bk], then it must satisfy
(b1 + b2) % m == 0, (b2 + b3) % m == 0, â€¦, (b_{k-1} + b_k) % m == 0.

We need to find the smallest number of such m-divisible arrays we can form
using all elements of a.

âš™ï¸ Key Insight â€” Work with Remainders

When we are working with divisibility by m,
the only thing that matters is the remainder (a[i] % m).

Letâ€™s replace each number by its remainder mod m.
Then, for two elements x and y to be adjacent in a group,
we need:

(
ğ‘¥
+
ğ‘¦
)
m
o
d
â€‰
â€‰
ğ‘š
=
0
(x+y)modm=0

That means:

ğ‘¦
m
o
d
â€‰
â€‰
ğ‘š
=
(
ğ‘š
âˆ’
ğ‘¥
)
m
o
d
â€‰
â€‰
ğ‘š
ymodm=(mâˆ’x)modm

So, remainder r can pair only with remainder (m - r).

ğŸ” Step 1: Count the frequency of each remainder

Letâ€™s count how many numbers have each remainder when divided by m.

Example:

m = 4
a = [2, 2, 8, 6, 9, 4]


Compute remainders:

2 % 4 = 2
2 % 4 = 2
8 % 4 = 0
6 % 4 = 2
9 % 4 = 1
4 % 4 = 0


So, frequencies:

cnt[0] = 2
cnt[1] = 1
cnt[2] = 3
cnt[3] = 0

ğŸ§  Step 2: Think in terms of pairs of remainders
1ï¸âƒ£ Case r = 0

Any two elements both having remainder 0 can be adjacent,
because (0 + 0) % m = 0.

So, all elements with remainder 0 can go into one single group.

ğŸ‘‰ If cnt[0] > 0, that contributes exactly 1 group to the answer.

2ï¸âƒ£ Case when m is even and r = m/2

For example, if m = 4, then r = 2.
Here, (2 + 2) % 4 = 0, so same-remainder elements can also be adjacent.
Thus, if there are any such elements, they can all go in one group.

ğŸ‘‰ If cnt[m/2] > 0, add 1 group.

3ï¸âƒ£ Other remainders r (1 â‰¤ r < m/2)

Now, r and mâˆ’r are complementary pairs.
For instance, when m = 4:

1 â†” 3

2 â†” 2 (handled separately)

These pairs are important because only these combinations make sum % m == 0.

Let:

x = cnt[r]
y = cnt[m - r]


Now we decide how many groups are needed to combine these two.

âš–ï¸ Step 3: How many groups do we need for each pair?

Letâ€™s analyze cases:

Case 1: both counts are zero

No elements â†’ skip.

Case 2: counts are equal (x == y > 0)

You can perfectly pair all of them together â€” for example:

r, (mâˆ’r), r, (mâˆ’r), ...


Everything can fit into one m-divisible group.

âœ… So, contribution = 1

Case 3: counts are different (x â‰  y)

Suppose x > y.
We can pair up y of them into one alternating chain like:

r, (mâˆ’r), r, (mâˆ’r), ...  (2*y elements)


Now, we have (x - y) extra elements of type r that cannot pair anymore.

These leftover elements cannot be attached to the previous array
(since adding two same remainders doesnâ€™t make sum divisible by m),
so each leftover needs its own array â€” except possibly one we can merge cleverly.

After optimizing (and proven in editorial), the number of required groups becomes:

âœ… 1 + (x - y - 1) = x - y (since one merged array + leftovers minus one)

So, generally, contribution = abs(x âˆ’ y).

Summary for each remainder pair:
Condition	Contribution to groups
both zero	0
x == y > 0	1
x != y	abs(x - y)
ğŸ§® Step 4: Combine everything

Algorithm:

Initialize answer = 0

If cnt[0] > 0 â†’ ans += 1

For every r in [1, m/2):

Let x = cnt[r], y = cnt[m - r]

If both zero â†’ continue

If equal â†’ ans += 1

Else â†’ ans += abs(x - y)

If m even and cnt[m/2] > 0 â†’ ans += 1

ğŸ’» Full C++ Code
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int t;
    cin >> t;
    while (t--) {
        int n, m;
        cin >> n >> m;
        vector<int> cnt(m, 0);

        for (int i = 0; i < n; i++) {
            long long x;
            cin >> x;
            cnt[x % m]++;
        }

        long long ans = 0;

        // Handle remainder 0
        if (cnt[0] > 0) ans++;

        // Handle pairs (r, m - r)
        for (int r = 1; r + r < m; r++) {
            int x = cnt[r], y = cnt[m - r];
            if (x == 0 && y == 0) continue;
            if (x == y) ans += 1;
            else ans += abs(x - y);
        }

        // Handle middle remainder if m even
        if (m % 2 == 0 && cnt[m/2] > 0)
            ans++;

        cout << ans << "\n";
    }
    return 0;
}

ğŸ§  Example Walkthrough
Example 1
n = 6, m = 4
a = [2, 2, 8, 6, 9, 4]


Remainders: [2,2,0,2,1,0]

cnt[0] = 2
cnt[1] = 1
cnt[2] = 3
cnt[3] = 0


Step-by-step:

cnt[0] > 0 â†’ ans = 1

r = 1, m - r = 3: x=1, y=0 â†’ add abs(1-0)=1 â†’ ans = 2

r = 2 is m/2 (since 4 even) â†’ cnt[2]=3>0 â†’ add 1 â†’ ans = 3

âœ… Final Answer = 3

Example 2
n = 10, m = 8
a = [1 1 1 5 2 4 4 8 6 7]


Remainders: [1,1,1,5,2,4,4,0,6,7]

cnt[0]=1
cnt[1]=3
cnt[2]=1
cnt[3]=0
cnt[4]=2
cnt[5]=1
cnt[6]=1
cnt[7]=1


Now:

cnt[0]>0 â†’ +1 (ans=1)

pairs:

(1,7): (3,1) â†’ +|3-1|=2 (ans=3)

(2,6): (1,1) â†’ +1 (ans=4)

(3,5): (0,1) â†’ +|0-1|=1 (ans=5)

m even, r=4: cnt[4]=2>0 â†’ +1 (ans=6)

âœ… Final Answer = 6

âœ… Example 3
n = 1, m = 1
a = [666]


All numbers mod 1 â†’ remainder 0.
cnt[0]=1 â†’ ans=1.

âœ… Output = 1

âœ… Example 4
n = 2, m = 2
a = [2,4]


Remainders: [0,0]
cnt[0]=2 â†’ ans=1 (all can go in one group).

âœ… Output = 1

ğŸ“Š Final Answers for the sample
Test	Input	Output
1	6 4 / 2 2 8 6 9 4	3
2	10 8 / 1 1 1 5 2 4 4 8 6 7	6
3	1 1 / 666	1
4	2 2 / 2 4	1

âœ… Outputs:

3
6
1
1

â±ï¸ Complexity
Operation	Cost
Counting remainders	O(n)
Processing all pairs	O(m)
Total per test	O(n + m)
Space	O(m)

Efficient for given constraints (â‰¤ 1e5).

Thatâ€™s the complete explanation:

remainder logic intuition

pairing principle

reasoning for each case

step-by-step walkthrough

final optimized C++ code
