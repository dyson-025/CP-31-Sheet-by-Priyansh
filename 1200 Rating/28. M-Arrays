🧩 Problem Restatement
link: https://codeforces.com/problemset/problem/1497/B
We are given:

an array a1, a2, …, an of positive integers

a positive integer m

We can divide the array into some number of subarrays (groups).
Each group should be m-divisible, meaning:

For every two adjacent numbers in that subarray, their sum is divisible by m.

Formally, if the array is [b1, b2, …, bk], then it must satisfy
(b1 + b2) % m == 0, (b2 + b3) % m == 0, …, (b_{k-1} + b_k) % m == 0.

We need to find the smallest number of such m-divisible arrays we can form
using all elements of a.

⚙️ Key Insight — Work with Remainders

When we are working with divisibility by m,
the only thing that matters is the remainder (a[i] % m).

Let’s replace each number by its remainder mod m.
Then, for two elements x and y to be adjacent in a group,
we need:

(
𝑥
+
𝑦
)
m
o
d
 
 
𝑚
=
0
(x+y)modm=0

That means:

𝑦
m
o
d
 
 
𝑚
=
(
𝑚
−
𝑥
)
m
o
d
 
 
𝑚
ymodm=(m−x)modm

So, remainder r can pair only with remainder (m - r).

🔎 Step 1: Count the frequency of each remainder

Let’s count how many numbers have each remainder when divided by m.

Example:

m = 4
a = [2, 2, 8, 6, 9, 4]


Compute remainders:

2 % 4 = 2
2 % 4 = 2
8 % 4 = 0
6 % 4 = 2
9 % 4 = 1
4 % 4 = 0


So, frequencies:

cnt[0] = 2
cnt[1] = 1
cnt[2] = 3
cnt[3] = 0

🧠 Step 2: Think in terms of pairs of remainders
1️⃣ Case r = 0

Any two elements both having remainder 0 can be adjacent,
because (0 + 0) % m = 0.

So, all elements with remainder 0 can go into one single group.

👉 If cnt[0] > 0, that contributes exactly 1 group to the answer.

2️⃣ Case when m is even and r = m/2

For example, if m = 4, then r = 2.
Here, (2 + 2) % 4 = 0, so same-remainder elements can also be adjacent.
Thus, if there are any such elements, they can all go in one group.

👉 If cnt[m/2] > 0, add 1 group.

3️⃣ Other remainders r (1 ≤ r < m/2)

Now, r and m−r are complementary pairs.
For instance, when m = 4:

1 ↔ 3

2 ↔ 2 (handled separately)

These pairs are important because only these combinations make sum % m == 0.

Let:

x = cnt[r]
y = cnt[m - r]


Now we decide how many groups are needed to combine these two.

⚖️ Step 3: How many groups do we need for each pair?

Let’s analyze cases:

Case 1: both counts are zero

No elements → skip.

Case 2: counts are equal (x == y > 0)

You can perfectly pair all of them together — for example:

r, (m−r), r, (m−r), ...


Everything can fit into one m-divisible group.

✅ So, contribution = 1

Case 3: counts are different (x ≠ y)

Suppose x > y.
We can pair up y of them into one alternating chain like:

r, (m−r), r, (m−r), ...  (2*y elements)


Now, we have (x - y) extra elements of type r that cannot pair anymore.

These leftover elements cannot be attached to the previous array
(since adding two same remainders doesn’t make sum divisible by m),
so each leftover needs its own array — except possibly one we can merge cleverly.

After optimizing (and proven in editorial), the number of required groups becomes:

✅ 1 + (x - y - 1) = x - y (since one merged array + leftovers minus one)

So, generally, contribution = abs(x − y).

Summary for each remainder pair:
Condition	Contribution to groups
both zero	0
x == y > 0	1
x != y	abs(x - y)
🧮 Step 4: Combine everything

Algorithm:

Initialize answer = 0

If cnt[0] > 0 → ans += 1

For every r in [1, m/2):

Let x = cnt[r], y = cnt[m - r]

If both zero → continue

If equal → ans += 1

Else → ans += abs(x - y)

If m even and cnt[m/2] > 0 → ans += 1

💻 Full C++ Code
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int t;
    cin >> t;
    while (t--) {
        int n, m;
        cin >> n >> m;
        vector<int> cnt(m, 0);

        for (int i = 0; i < n; i++) {
            long long x;
            cin >> x;
            cnt[x % m]++;
        }

        long long ans = 0;

        // Handle remainder 0
        if (cnt[0] > 0) ans++;

        // Handle pairs (r, m - r)
        for (int r = 1; r + r < m; r++) {
            int x = cnt[r], y = cnt[m - r];
            if (x == 0 && y == 0) continue;
            if (x == y) ans += 1;
            else ans += abs(x - y);
        }

        // Handle middle remainder if m even
        if (m % 2 == 0 && cnt[m/2] > 0)
            ans++;

        cout << ans << "\n";
    }
    return 0;
}

🧠 Example Walkthrough
Example 1
n = 6, m = 4
a = [2, 2, 8, 6, 9, 4]


Remainders: [2,2,0,2,1,0]

cnt[0] = 2
cnt[1] = 1
cnt[2] = 3
cnt[3] = 0


Step-by-step:

cnt[0] > 0 → ans = 1

r = 1, m - r = 3: x=1, y=0 → add abs(1-0)=1 → ans = 2

r = 2 is m/2 (since 4 even) → cnt[2]=3>0 → add 1 → ans = 3

✅ Final Answer = 3

Example 2
n = 10, m = 8
a = [1 1 1 5 2 4 4 8 6 7]


Remainders: [1,1,1,5,2,4,4,0,6,7]

cnt[0]=1
cnt[1]=3
cnt[2]=1
cnt[3]=0
cnt[4]=2
cnt[5]=1
cnt[6]=1
cnt[7]=1


Now:

cnt[0]>0 → +1 (ans=1)

pairs:

(1,7): (3,1) → +|3-1|=2 (ans=3)

(2,6): (1,1) → +1 (ans=4)

(3,5): (0,1) → +|0-1|=1 (ans=5)

m even, r=4: cnt[4]=2>0 → +1 (ans=6)

✅ Final Answer = 6

✅ Example 3
n = 1, m = 1
a = [666]


All numbers mod 1 → remainder 0.
cnt[0]=1 → ans=1.

✅ Output = 1

✅ Example 4
n = 2, m = 2
a = [2,4]


Remainders: [0,0]
cnt[0]=2 → ans=1 (all can go in one group).

✅ Output = 1

📊 Final Answers for the sample
Test	Input	Output
1	6 4 / 2 2 8 6 9 4	3
2	10 8 / 1 1 1 5 2 4 4 8 6 7	6
3	1 1 / 666	1
4	2 2 / 2 4	1

✅ Outputs:

3
6
1
1

⏱️ Complexity
Operation	Cost
Counting remainders	O(n)
Processing all pairs	O(m)
Total per test	O(n + m)
Space	O(m)

Efficient for given constraints (≤ 1e5).

That’s the complete explanation:

remainder logic intuition

pairing principle

reasoning for each case

step-by-step walkthrough

final optimized C++ code
