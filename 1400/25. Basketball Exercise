üß† Problem idea (short)

2 rows, each with n students and heights.

You pick students left ‚Üí right (index strictly increasing).

You cannot pick two consecutive from same row.

Goal: maximize total height.
These are the exact constraints from the statement.

üîç Key observation

At column i you have 3 choices:

1Ô∏è‚É£ Pick from top row
2Ô∏è‚É£ Pick from bottom row
3Ô∏è‚É£ Pick none

Because:

If you pick top at i, previous pick must be bottom (or skip)

Symmetric for bottom

Increasing index means we process left‚Üíright

This screams DP on index.

üß© DP State (clean version)

Let:

a[i] = top height

b[i] = bottom height

Define:

dpTop[i]    = best sum if we pick top at i
dpBottom[i] = best sum if we pick bottom at i
dpSkip[i]   = best sum if we pick none at i

üîÑ Transitions
Pick top

Previous must NOT be top:

dpTop[i] = max(dpBottom[i-1], dpSkip[i-1]) + a[i]

Pick bottom
dpBottom[i] = max(dpTop[i-1], dpSkip[i-1]) + b[i]

Skip
dpSkip[i] = max(dpTop[i-1], dpBottom[i-1], dpSkip[i-1])


This matches editorial intuition ‚Äî we always extend from the opposite row or skipped state.

‚úÖ Answer
ans = max(dpTop[n], dpBottom[n], dpSkip[n])

‚ö° Even simpler (most common CF solution)

We can compress states to just two:

dpTop[i] = max(dpBottom[i-1], dpBottom[i-2]) + a[i]
dpBottom[i] = max(dpTop[i-1], dpTop[i-2]) + b[i]


(because skipping is implicitly handled)

This is the zig-zag DP described in editorial.

üßæ Clean C++ solution
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    int n;
    cin >> n;

    vector<long long> a(n+1), b(n+1);
    for(int i=1;i<=n;i++) cin >> a[i];
    for(int i=1;i<=n;i++) cin >> b[i];

    vector<long long> dpTop(n+1,0), dpBottom(n+1,0);

    dpTop[1] = a[1];
    dpBottom[1] = b[1];

    for(int i=2;i<=n;i++){
        dpTop[i] = max(dpBottom[i-1], dpBottom[i-2]) + a[i];
        dpBottom[i] = max(dpTop[i-1], dpTop[i-2]) + b[i];
    }

    cout << max(dpTop[n], dpBottom[n]) << "\n";
}


Time: O(n)
Memory: O(n) (can compress to O(1))

üéØ Intuition to remember (important for you as CPer)

This problem is basically:

‚Äú2 tracks, move forward, can‚Äôt take same track twice ‚Äî maximize sum‚Äù

Whenever you see:

2 rows / 2 options

alternating restriction

maximize sum

Think:
‚úÖ DP with ‚Äúlast chosen type‚Äù state

This pattern repeats A LOT in 1300‚Äì1500 CF.  
üß† Recall the idea

At column i we only need:

top[i-1], top[i-2]

bottom[i-1], bottom[i-2]

So we store 4 variables and roll them forward.

Transitions:

newTop    = max(bottom1, bottom2) + a[i]
newBottom = max(top1, top2) + b[i]


Then shift:

top2 = top1
top1 = newTop
bottom2 = bottom1
bottom1 = newBottom


Answer:

max(top1, bottom1)

‚úÖ O(1) C++ solution
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    int n;
    cin >> n;

    vector<long long> a(n+1), b(n+1);
    for(int i=1;i<=n;i++) cin >> a[i];
    for(int i=1;i<=n;i++) cin >> b[i];

    long long top1 = a[1], bottom1 = b[1];
    long long top2 = 0, bottom2 = 0;

    for(int i=2;i<=n;i++){
        long long newTop = max(bottom1, bottom2) + a[i];
        long long newBottom = max(top1, top2) + b[i];

        top2 = top1;
        top1 = newTop;
        bottom2 = bottom1;
        bottom1 = newBottom;
    }

    cout << max(top1, bottom1) << "\n";
}

üéØ Intuition to lock in

You‚Äôre basically doing:

‚Äúzig-zag max sum between two rows‚Äù

And since each state depends only on last two columns ‚Üí arrays unnecessary ‚Üí rolling vars = O(1).

This trick shows up everywhere in CF DP ‚Äî once you see
dp[i] depends on dp[i-1] and dp[i-2]
üëâ immediately think state compression.
