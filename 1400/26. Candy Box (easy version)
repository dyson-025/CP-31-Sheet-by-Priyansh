ğŸ§  Core Idea â€“ Candy Box (Easy)
ğŸ“Œ What is asked?
You want to pick candies such that:


For each type, number of candies taken is distinct.


Maximize total candies in gift.



ğŸ” Key Observations


You only care about frequency of each type.


Example:
1 1 1 2 2 3 â†’ frequencies = [3,2,1]




Gift rule:


If you pick counts â†’ must be all different


Example valid â†’ 3,2,1


Example invalid â†’ 2,2




Best strategy:


Use largest frequencies first


Each next chosen count must be strictly smaller





ğŸ’¡ Greedy Insight
If you pick:
k, k-1, k-2, ...

you maximize total sum.
Because:


Bigger numbers give more candies.


But must stay â‰¤ actual frequency.



ğŸ§© Algorithm Steps
Step 1: Count frequencies
Use map or array.
Step 2: Store frequencies in vector
Example:
[4,4,3,2,1]

Step 3: Sort descending
[4,4,3,2,1]

Step 4: Greedy picking
Maintain:
k = n (max allowed next frequency)

For each frequency f:
k = min(k, f)
if k <= 0 break
ans += k
k--


ğŸ§® Why This Works
We ensure:


Pick â‰¤ available candies of type


Pick < previous picked count (distinct condition)



âœï¸ Dry Run Example
Input:
8
1 4 8 4 5 6 3 8

Frequencies:
4 â†’ 2
8 â†’ 2
others â†’ 1

Vector:
[2,2,1,1,1,1]

Process:
k=8
Take min(8,2)=2 â†’ ans=2 â†’ k=1
Take min(1,2)=1 â†’ ans=3 â†’ k=0
Stop

Answer = 3

â± Complexity
Per query:
Frequency count â†’ O(n)
Sort â†’ O(n log n)
Greedy â†’ O(n)

Total:
O(N log N) overall (since sum n â‰¤ 2e5)


ğŸ§  Pattern Recognition (Important for CP)
When you see:


Distinct counts


Maximize total


Frequencies involved


ğŸ‘‰ Try:
Sort frequencies
Greedy decreasing assignment


ğŸ”¥ Why Your Code is Correct
Your logic:
âœ” Frequency map
âœ” Sorting frequencies descending
âœ” Greedy decreasing k
âœ” Early break when zero
Perfect.

ğŸ“ Short Revision Notes (Exam / Contest)
Candy Box Trick
1. Count freq of each type
2. Sort freq descending
3. prev = large number
4. For each freq:
      take = min(freq, prev)
      if take == 0 break
      ans += take
      prev = take - 1
