âš”ï¸ B. Mahmoud and Ehab and the Bipartiteness
link: https://codeforces.com/problemset/problem/862/B
ğŸ§  Problem Summary

We are given a tree of n nodes.
We must find the maximum number of extra edges that can be added such that:

The graph remains bipartite.

The graph remains simple (no self-loops, no multiple edges).

ğŸ§© Key Observations

A tree is always bipartite by definition (it has no cycles).

You can color it with two colors (red and white) such that
every edge connects nodes of different colors.

In a bipartite graph, edges only connect across the two sets â€” never within one set.

ğŸ§® Mathematical Idea

Let:

red = number of vertices in the red set

white = number of vertices in the white set

In a complete bipartite graph between these two sets, the maximum number of edges possible is:

max edges=redÃ—white

But the tree already contains (n - 1) edges,
so the extra edges you can add are:


answer=(redÃ—white)âˆ’(nâˆ’1)

Thatâ€™s the key formula âœ…

ğŸ§  Step-by-Step Approach

Input the number of nodes n and the tree edges.

Build an adjacency list.

Use DFS (or BFS) to color the tree in two colors.

Start with node 1 and color it, say, white = 0.

Alternate color for children (!color).

Count how many nodes are red and white.

Apply the formula:

Answer=redÃ—whiteâˆ’(nâˆ’1)
âœ… Correct Code
#include <bits/stdc++.h>
using namespace std;

#define fast_io ios::sync_with_stdio(false); cin.tie(nullptr);
#define ll long long

ll red = 0, white = 0;

void dfs(ll node, ll color, vector<vector<ll>> &adj, vector<ll> &vis) {
    vis[node] = 1;
    if (color == 1) red++;
    else white++;

    for (auto it : adj[node]) {
        if (!vis[it]) {
            dfs(it, !color, adj, vis);
        }
    }
}

void solve() {
    ll n;
    cin >> n;

    vector<vector<ll>> adj(n + 1);
    vector<ll> vis(n + 1, 0);

    for (int i = 1; i < n; i++) {
        ll u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    dfs(1, 0, adj, vis);

    cout << (red * white - (n - 1)) << "\n";
}

int main() {
    fast_io
    solve();
    return 0;
}

ğŸ§© Example Walkthrough
Example 1:
n = 3
1 - 2
1 - 3


Coloring:

1 â†’ white
2, 3 â†’ red


red = 2

white = 1
â†’ red Ã— white = 2
â†’ edges already = 2
âœ… answer = 2 - 2 = 0

Example 2:
n = 5
1-2, 2-3, 3-4, 4-5


Coloring alternates:

1 (white), 2 (red), 3 (white), 4 (red), 5 (white)


red = 2

white = 3
â†’ red Ã— white = 6
â†’ edges already = 4
âœ… answer = 6 - 4 = 2

âš ï¸ Your Original Mistakes
âŒ Mistake	ğŸ’¡ Fix
vector<vector<ll>> adj passed by value in DFS	Pass by reference â†’ &adj
vis[node]++ used	Should be vis[node] = 1; for clarity
You expected O(n) but got TLE	Due to O(nÂ²) copying caused by pass-by-value
Possibly misunderstood formula	Correct formula â†’ white * red - (n - 1)
âš™ï¸ Complexity Analysis
Operation	Complexity
Building adjacency list	O(n)
DFS traversal	O(n)
Final formula	O(1)
Total	âœ… O(n)

Space Complexity â†’ O(n) for adjacency + visited array.

ğŸ Final Summary

âœ… Tree â†’ Always bipartite
âœ… Color using DFS
âœ… Count red and white
âœ… Use formula â†’ white * red - (n - 1)
âœ… Pass adjacency by reference to avoid TLE
