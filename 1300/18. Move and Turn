ðŸ“ SOLUTION NOTES â€” B. Move and Turn
Problem Summary

A robot:

Starts at (0, 0)

Takes exactly n steps

First move: any direction (N/S/E/W)

Every next step: must turn left or right (cannot continue straight)

Goal:
Count how many distinct final coordinates the robot can reach.

n â‰¤ 1000 so we need formula, not simulation.

ðŸ§  Key Insight (Parity Pattern)

Since robot MUST turn 90Â° every step:

Step 1 â†’ horizontal or vertical

Step 2 â†’ perpendicular direction

Step 3 â†’ perpendicular again

Step 4 â†’ again perpendicular

â€¦

The robot's path always alternates axis:

X, Y, X, Y, X, Y, â€¦


So final point depends only on number of X moves and number of Y moves.

â­ Case 1: n is even

Let n = 2k:

k steps in X direction

k steps in Y direction

All combinations of:

x = (# right) - (# left)
y = (# up) - (# down)


Since X and Y movements are independent and symmetric:

Possible x-values = -(k), -(k-1), â€¦, +k
Count = k + k + 1 = 2k + 1

Same for y â†’ also 2k + 1

Thus total positions:

(2k + 1) * (2k + 1) = (k + 1)^2

âœ” Formula (even n):
answer = (k + 1) * (k + 1)

â­ Case 2: n is odd

Let n = 2k âˆ’ 1
But easier to work with (n+1) which is even:

n+1 = 2k


If we simulate n+1 steps, robot returns to same parity region, but one extra backtrack reduces symmetry.

Final result:

answer = 2 * k * (k + 1)


Where k = (n + 1) / 2.

This is a known derived result from geometry + parity.

âœ¨ Final Formulas
If n is even:
n = 2k
ans = (k + 1)^2

If n is odd:
n = 2k - 1
ans = 2 * k * (k + 1)
(where k = (n + 1) / 2)

ðŸ’» Final Clean Code (Your Code)
void solve() {
    ll n;
    cin >> n;

    if (n % 2 == 0) {
        ll k = n / 2;
        cout << (k + 1) * (k + 1) << "\n";
    } else {
        n++;
        ll k = n / 2;
        cout << 2LL * k * (k + 1) << "\n";
    }
}

ðŸ”¥ Summary

Robot alternates X/Y moves â†’ leads to geometric symmetry.

Even n â†’ square grid of reachable points â†’ (k+1)^2.

Odd n â†’ rectangle-like count â†’ 2 â‹… k â‹… (k+1).

This is why the super-simple formula exists.
