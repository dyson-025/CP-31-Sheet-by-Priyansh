ğŸ“˜ Notes for B. WOW Factor (Codeforces)
âœ… Problem Summary

You are given a string s made of only:

'v'

'o'

Here:

âœ” Every "vv" is equivalent to a single "w"

(but multiple overlapping "vv"s count!)

Example:
vvvv contains 3 "w":

(1,2)

(2,3)

(3,4)

ğŸ¯ Goal

Count the number of subsequences equal to:

w o w


But since:

w â†’ "vv"


We actually need to count subsequences of the form:

"vv"  o  "vv"

ğŸ§  Key Observation (The Core Trick)

We only care about "vv" pairs, not single v's.

Let's mark every "vv" as a countable unit.

For each 'o' in the string:

Number of WOWs contributed by this 'o' =
(# of "vv" before it) Ã— (# of "vv" after it)


This works because:

Each "vv" before forms a left "w".

Each "vv" after forms a right "w".

Sum over all 'o'.

ğŸ’¡ Why Overlapping â€œvvâ€ Count?

Example: vvvv

Indices: 1 2 3 4
Pairs:

(1,2)

(2,3)

(3,4)

All are valid because subsequence allows picking characters at different positions.

ğŸ§© Steps to Solve
1ï¸âƒ£ Build prefix array pf[i] = total â€œvvâ€ pairs till index i

Walk through string:

if s[i]=='v' & s[i-1]=='v' â†’ found a "vv" pair â†’ d++
pf[i] = d

2ï¸âƒ£ For every 'o', compute:
left  = number of "vv" before i = pf[i]
right = number of "vv" after i = pf[n-1] - pf[i]
ans += left * right

3ï¸âƒ£ Print ans
ğŸ§ª Example Walkthrough
Input:
vvvovvv


vvv has 2 overlapping "vv":

(1,2)

(2,3)

Similarly last vvv has 2.

At the 'o':

left = 2
right = 2
so contribution = 2 Ã— 2 = 4

âœ” Output = 4

ğŸ§¾ Clean & Commented Version of Your Code
#include <bits/stdc++.h>
using namespace std;

#define ll long long

void solve() {
    string s;
    cin >> s;

    int n = s.size();
    vector<ll> pf(n, 0);

    // Count vv pairs in prefix
    ll count_vv = 0;
    for (int i = 1; i < n; i++) {
        if (s[i] == 'v' && s[i - 1] == 'v')
            count_vv++;
        pf[i] = count_vv;
    }

    ll ans = 0;

    // For every 'o', count left_vv * right_vv
    for (int i = 0; i < n; i++) {
        if (s[i] == 'o') {
            ll left = pf[i];
            ll right = pf[n - 1] - pf[i];
            ans += left * right;
        }
    }

    cout << ans << "\n";
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t = 1;
    cin >> t;
    while (t--) solve();

    return 0;
}

ğŸ“š Add These Points to Your DSA Notes
âœ” "vv" â†’ contributes one w

But they overlap.

âœ” WOW = Left_w Ã— Right_w for each 'o'
âœ” Use prefix counts to avoid O(NÂ²)
âœ” Complexity:

O(n) time
O(n) memory

âœ” Valid even if string is not derived from actual wâ†’vv typing
