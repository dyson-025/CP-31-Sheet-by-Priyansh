âœ… CF Problem: Scoring Subsequences â€” Notes
link: https://codeforces.com/contest/1794/problem/C
ğŸ¯ Goal

For each prefix a[1..k] of a non-decreasing array, find the maximum length d of a subsequence that gives the maximum score.

Score of a subsequence 
[ğ‘ 1,...,ğ‘ ğ‘‘][s1	â€‹,..., sd	â€‹]:

ğ‘ 
1
â‹…
ğ‘ 
2
â‹…
â€¦
â‹…
ğ‘ 
ğ‘‘
ğ‘‘
!
d!
s
1
	â€‹

â‹…s
2
	â€‹
â€¦â‹…sd	â€‹	â€‹

ğŸ§  Key Insight

To maximize score, we want largest values.

For prefix ending at i:

Best subsequence is always the last d elements (because array is non-decreasing)

Let those be a[i-d+1 ... i]

Minimum in that block is a[i-d+1]

For subsequence of size d to be valid:

a[iâˆ’d+1]â‰¥d

This is the core condition.

So for each i, find max d such that:

a[i - d + 1] â‰¥ d

ğŸ” Why Condition Works

d! grows fast â†’ only want large enough numbers

With sorted array, the smallest in chosen block determines possibility

So if smallest â‰¥ size â†’ good block âœ…

âœ… Approach

For each index i:

Binary search d from 1 to i+1

Check if a[i - d + 1] >= d

Max d is answer for that prefix

Time: O(n log n)
Works because prefix & sorted.

ğŸ§ª Example

Array: 1 2 3

i = 2 â†’ last elements
Try d=3: a[0] = 1 >= 3 âŒ
Try d=2: a[1] = 2 >= 2 âœ…

Answer = 2

ğŸ’¡ Important Takeaways

Non-decreasing array = greedy suffix check

Suffix of size d must satisfy smallest â‰¥ d

Binary search = efficient

Output per prefix

âœ… Final Code (with comments)
void solve() {
    ll n; cin >> n;
    vector<ll> a(n);
    for (auto &x : a) cin >> x;

    for (int i = 0; i < n; i++) {
        int l = 1, r = i + 1, ans = 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            // Check the smallest in last 'mid' elements
            if (a[i - mid + 1] >= mid) {
                ans = mid;
                l = mid + 1;
            } else r = mid - 1;
        }
        cout << ans << " ";
    }
    cout << "\n";
}

ğŸ“ Short Mnemonic

"Last d values must all be â‰¥ d"

ğŸ Bonus Tip

This problem pattern = "greedy suffix check with binary search"
Similar to:

Good subsequence problems

K-max constraints in sorted array
