✅ CF Problem: Scoring Subsequences — Notes
link: https://codeforces.com/contest/1794/problem/C
🎯 Goal

For each prefix a[1..k] of a non-decreasing array, find the maximum length d of a subsequence that gives the maximum score.

Score of a subsequence 
[𝑠1,...,𝑠𝑑][s1	​,..., sd	​]:

𝑠
1
⋅
𝑠
2
⋅
…
⋅
𝑠
𝑑
𝑑
!
d!
s
1
	​

⋅s
2
	​
…⋅sd	​	​

🧠 Key Insight

To maximize score, we want largest values.

For prefix ending at i:

Best subsequence is always the last d elements (because array is non-decreasing)

Let those be a[i-d+1 ... i]

Minimum in that block is a[i-d+1]

For subsequence of size d to be valid:

a[i−d+1]≥d

This is the core condition.

So for each i, find max d such that:

a[i - d + 1] ≥ d

🔍 Why Condition Works

d! grows fast → only want large enough numbers

With sorted array, the smallest in chosen block determines possibility

So if smallest ≥ size → good block ✅

✅ Approach

For each index i:

Binary search d from 1 to i+1

Check if a[i - d + 1] >= d

Max d is answer for that prefix

Time: O(n log n)
Works because prefix & sorted.

🧪 Example

Array: 1 2 3

i = 2 → last elements
Try d=3: a[0] = 1 >= 3 ❌
Try d=2: a[1] = 2 >= 2 ✅

Answer = 2

💡 Important Takeaways

Non-decreasing array = greedy suffix check

Suffix of size d must satisfy smallest ≥ d

Binary search = efficient

Output per prefix

✅ Final Code (with comments)
void solve() {
    ll n; cin >> n;
    vector<ll> a(n);
    for (auto &x : a) cin >> x;

    for (int i = 0; i < n; i++) {
        int l = 1, r = i + 1, ans = 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            // Check the smallest in last 'mid' elements
            if (a[i - mid + 1] >= mid) {
                ans = mid;
                l = mid + 1;
            } else r = mid - 1;
        }
        cout << ans << " ";
    }
    cout << "\n";
}

📝 Short Mnemonic

"Last d values must all be ≥ d"

🎁 Bonus Tip

This problem pattern = "greedy suffix check with binary search"
Similar to:

Good subsequence problems

K-max constraints in sorted array
