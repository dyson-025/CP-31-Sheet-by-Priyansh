ðŸ§© Problem Summary
link: https://codeforces.com/problemset/problem/665/C
Youâ€™re given a string s of lowercase letters.
We must change the minimum number of characters so that no two adjacent characters are the same.

A string is simple if:

âˆ€ i: s[i] != s[i+1]


You can change characters arbitrarily, but must use lowercase English letters only.

ðŸŽ¯ Goal

Make the string simple with minimum changes.

ðŸ§  Intuition & Logic

If two consecutive letters are equal â†’ thatâ€™s bad, we must change one of them.

Letâ€™s say:

s = a a b


At index 1 (0-based):

s[0] = a, s[1] = a â†’ conflict

Change s[1] to something else.

But be careful:

It must not equal s[i-1] (previous char)

It must not equal s[i+1] (next char) â€” otherwise we create a new duplicate later.

So for each position i (starting from left):

If s[i] == s[i-1], change s[i].

Choose the smallest character c âˆˆ 'a'..'z' such that:

c != s[i-1] and (i+1 < n ? c != s[i+1] : true)


This guarantees minimal and safe replacement.

âš™ï¸ Implementation Strategy

Iterate from i = 1 to n-1

Whenever s[i] == s[i-1]:

Pick replacement char from 'a'..'z'

Skip chars that equal s[i-1] or s[i+1]

Replace s[i]

ðŸ§® Complexity
Operation	Time
Scan string	O(n)
Each replacement check (constant alphabet 26)	O(1)
âœ… Total	O(n)

Efficient even for |s| â‰¤ 2Ã—10âµ.

âœ… Full C++ Solution
#include <bits/stdc++.h>
using namespace std;

#define fast_io ios::sync_with_stdio(false); cin.tie(nullptr);
#define ll long long
#define endl '\n'

void solve() {
    string s;
    cin >> s;
    int n = s.size();

    for (int i = 1; i < n; i++) {
        if (s[i] == s[i - 1]) {
            for (char c = 'a'; c <= 'z'; c++) {
                if (c != s[i - 1] && (i + 1 == n || c != s[i + 1])) {
                    s[i] = c;
                    break;
                }
            }
        }
    }

    cout << s << endl;
}

int main() {
    fast_io;
    solve();
    return 0;
}

ðŸ§© Example Walkthrough
Example 1
Input:  aab


Steps:

i = 1 â†’ s[1] == s[0] ('a')
   â†’ Try c='a' âŒ same as prev
   â†’ Try c='b' âœ… != 'a' and != next ('b')
Result: "bab"


âœ… Output â†’ bab

Example 2
Input:  caaab


Steps:

i=1: 'a' == 'c'? âŒ
i=2: 'a' == 'a'? âœ… change
   Try 'a' âŒ same
   Try 'b' âœ… (next is 'a')
â†’ c a b a b
i=3: 'a' == 'b'? âŒ
i=4: ok


âœ… Output â†’ cabab

Example 3
Input: zscoder


No duplicates â†’ unchanged âœ…
Output â†’ zscoder

ðŸ’¡ Key Insights to Remember
Concept	Explanation
Greedy fix left-to-right	ensures minimal replacements
Only check 3 letters	current, prev, next
Constant alphabet	ensures O(n) total
Any valid solution	acceptable (not unique)
