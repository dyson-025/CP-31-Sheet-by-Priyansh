‚úÖ Problem Summary
link: https://codeforces.com/problemset/problem/1915/E
You are given an array where:

Iulia drinks only from odd-indexed glasses

Her date drinks only from even-indexed glasses

(Indexes are 1-based in problem, but in array they are 0-based)

We need to check if there exists any contiguous subarray l...r such that:

Sum of juice from odd positions inside subarray =
Sum of juice from even positions inside subarray

üéØ Key Observation

You don‚Äôt check all subarrays (too slow).
Instead, use prefix difference method:

Define prefix:

epf[i] = sum of elements at even indices (1-based) from 1..i
opf[i] = sum of elements at odd indices (1-based) from 1..i


Then difference:

diff[i] = epf[i] - opf[i]

Important Insight

For a subarray (l..r) to be valid:

(epf[r] - epf[l-1]) = (opf[r] - opf[l-1])


Rearrange:

(epf[r] - opf[r]) = (epf[l-1] - opf[l-1])


So, if some prefix difference diff[x] repeats, then between those indices we have equal juice sum.

This becomes a prefix hash existence problem like finding zero-sum subarray.

Also check diff = 0 prefix itself ‚Üí subarray starts from index 1.

‚úÖ Approach

Build prefix sums for even and odd positions

Compute diff = epf - opf

If any diff repeats ‚Üí YES

If no repetition ‚Üí NO

Time Complexity: O(n) per test
Memory: O(n)

‚ú® Example Walkthrough

Example: 1 3 2

i	val	epf	opf	diff
0	1	1	0	1
1	3	1	3	-2
2	2	3	3	0 ‚úÖ

diff = 0 ‚Üí subarray (1..3) is valid

‚úÖ Final Working Code
#include <bits/stdc++.h>
using namespace std;
#define ll long long

void solve(){
    ll n; 
    cin >> n;
    vector<ll> v(n);
    for(auto &x : v) cin >> x;

    vector<ll> epf(n), opf(n);
    
    // initialize based on 1-based parity
    epf[0] = v[0]; 
    opf[0] = 0;

    for(int i = 1; i < n; i++){
        epf[i] = epf[i-1];
        opf[i] = opf[i-1];
        if(i % 2 == 0) epf[i] += v[i];  // (i+1) is odd
        else opf[i] += v[i];          // (i+1) is even
    }

    map<ll,int> seen;
    seen[0] = 1; // diff = 0 before starting any prefix

    for(int i = 0; i < n; i++){
        ll diff = epf[i] - opf[i];

        if(seen.count(diff)){ 
            cout << "YES\n";
            return;
        }
        seen[diff]++;
    }

    cout << "NO\n";
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t; 
    cin >> t;
    while(t--) solve();
}

üß† Why This Works

We reduce parity-based subarray sum matching to checking prefix differences.
Same difference seen twice ‚üπ Equal subarray contribution for odd & even.

This is similar to:

Prefix XOR equal ‚Üí subarray XOR zero

Prefix Sum equal ‚Üí subarray sum zero

üéÅ Tips for Interview + CP
Concept Used	Explanation
Parity prefix sums	Handle odd/even positions differently
Prefix difference map	Detect equal contribution range
Hashing/Map	O(n) detection
Zero-sum subarray trick	Same principle
